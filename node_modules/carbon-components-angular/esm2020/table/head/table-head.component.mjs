import { Component, Input, Output, EventEmitter } from "@angular/core";
import { getScrollbarWidth } from "carbon-components-angular/utils";
import * as i0 from "@angular/core";
import * as i1 from "carbon-components-angular/i18n";
import * as i2 from "@angular/common";
import * as i3 from "./table-head-cell.component";
import * as i4 from "./table-head-checkbox.component";
import * as i5 from "./table-head-expand.component";
/**
 * A subcomponent that creates the thead of the table
 *
 * ## Basic usage
 *
 * ```html
 * 	<thead cdsTableHead [model]="model"></thead>
 * ```
 */
export class TableHead {
    constructor(i18n) {
        this.i18n = i18n;
        this.showSelectionColumn = true;
        this.enableSingleSelect = false;
        this.selectAllCheckboxSomeSelected = false;
        this.selectAllCheckbox = false;
        this.skeleton = false;
        this.stickyHeader = false;
        /**
         * Setting sortable to false will disable all headers including headers which are sortable. Is is
         * possible to set the sortable state on the header item to disable/enable sorting for only some headers.
         */
        this.sortable = true;
        /**
         * Emits an index of the column that wants to be sorted.
         */
        this.sort = new EventEmitter();
        /**
         * Emits if all rows are selected.
         *
         * @param model
         */
        this.selectAll = new EventEmitter();
        /**
         * Emits if all rows are deselected.
         *
         * @param model
         */
        this.deselectAll = new EventEmitter();
        this.scrollbarWidth = 0;
        this._checkboxHeaderLabel = this.i18n.getOverridable("TABLE.CHECKBOX_HEADER");
        this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
        this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
        this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
    }
    set checkboxHeaderLabel(value) {
        this._checkboxHeaderLabel.override(value);
    }
    get checkboxHeaderLabel() {
        return this._checkboxHeaderLabel.value;
    }
    set sortDescendingLabel(value) {
        this._sortDescendingLabel.override(value);
    }
    get sortDescendingLabel() {
        return this._sortDescendingLabel.value;
    }
    set sortAscendingLabel(value) {
        this._sortAscendingLabel.override(value);
    }
    get sortAscendingLabel() {
        return this._sortAscendingLabel.value;
    }
    set filterTitle(value) {
        this._filterTitle.override(value);
    }
    get filterTitle() {
        return this._filterTitle.value;
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.scrollbarWidth = getScrollbarWidth();
        });
    }
    onSelectAllCheckboxChange() {
        if (!this.selectAllCheckbox && !this.selectAllCheckboxSomeSelected) {
            this.selectAll.emit(this.model);
        }
        else {
            this.deselectAll.emit(this.model);
        }
    }
    getCheckboxHeaderLabel() {
        return this._checkboxHeaderLabel.subject;
    }
    getSortDescendingLabel() {
        return this._sortDescendingLabel.subject;
    }
    getSortAscendingLabel() {
        return this._sortAscendingLabel.subject;
    }
    getFilterTitle() {
        return this._filterTitle.subject;
    }
}
TableHead.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TableHead, deps: [{ token: i1.I18n }], target: i0.ɵɵFactoryTarget.Component });
TableHead.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: TableHead, selector: "[cdsTableHead], [ibmTableHead]", inputs: { model: "model", showSelectionColumn: "showSelectionColumn", enableSingleSelect: "enableSingleSelect", selectAllCheckboxSomeSelected: "selectAllCheckboxSomeSelected", selectAllCheckbox: "selectAllCheckbox", skeleton: "skeleton", stickyHeader: "stickyHeader", sortable: "sortable", checkboxHeaderLabel: "checkboxHeaderLabel", sortDescendingLabel: "sortDescendingLabel", sortAscendingLabel: "sortAscendingLabel", filterTitle: "filterTitle" }, outputs: { sort: "sort", selectAll: "selectAll", deselectAll: "deselectAll" }, ngImport: i0, template: `
	<ng-container *ngIf="model">
		<tr>
			<th
				cdsTableHeadExpand
				*ngIf="model.hasExpandableRows()"
				scope="col"
				[ngClass]="{'cds--table-expand-v2': stickyHeader}"
				[id]="model.getId('expand')">
			</th>
			<th
				*ngIf="!skeleton && showSelectionColumn && enableSingleSelect"
				scope="col"
				[id]="model.getId('select')">
				<!-- add width 0; since the carbon styles don't seem to constrain this headers width -->
			</th>
			<th
				cdsTableHeadCheckbox
				*ngIf="!skeleton && showSelectionColumn && !enableSingleSelect"
				scope="col"
				[checked]="selectAllCheckbox"
				[indeterminate]="selectAllCheckboxSomeSelected"
				[ariaLabel]="getCheckboxHeaderLabel()"
				[skeleton]="skeleton"
				[name]="model.getHeaderId('select')"
				(change)="onSelectAllCheckboxChange()"
				[id]="model.getId('select')">
			</th>
			<ng-container *ngFor="let column of model.header; let i = index">
				<th
					*ngIf="column && column.visible"
					[ngStyle]="column.style"
					cdsTableHeadCell
					scope="col"
					[class]="column.className"
					[sortable]="sortable"
					[skeleton]="skeleton"
					[id]="model.getId(i)"
					[column]="column"
					[filterTitle]="getFilterTitle()"
					[attr.colspan]="column.colSpan"
					[attr.rowspan]="column.rowSpan"
					(sort)="sort.emit(i)">
				</th>
			</ng-container>
			<th *ngIf="!skeleton && stickyHeader && scrollbarWidth"
				scope="col"
				[ngStyle]="{'width': scrollbarWidth + 'px', 'padding': 0, 'border': 0}">
				<!--
					Scrollbar pushes body to the left so this header column is added to push
					the title bar the same amount and keep the header and body columns aligned.
				-->
			</th>
		</tr>
	</ng-container>
	<ng-content></ng-content>
	`, isInline: true, styles: [".cds--table-expand-v2{padding-left:2.5rem}\n"], dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: i3.TableHeadCell, selector: "[cdsTableHeadCell], [ibmTableHeadCell]", inputs: ["column", "skeleton", "sortable", "sortDescendingLabel", "sortAscendingLabel", "filterTitle"], outputs: ["sort"] }, { kind: "component", type: i4.TableHeadCheckbox, selector: "[cdsTableHeadCheckbox], [ibmTableHeadCheckbox]", inputs: ["checked", "indeterminate", "skeleton", "name", "ariaLabel"], outputs: ["change"] }, { kind: "component", type: i5.TableHeadExpand, selector: "[cdsTableHeadExpand], [ibmTableHeadExpand]" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TableHead, decorators: [{
            type: Component,
            args: [{ selector: "[cdsTableHead], [ibmTableHead]", template: `
	<ng-container *ngIf="model">
		<tr>
			<th
				cdsTableHeadExpand
				*ngIf="model.hasExpandableRows()"
				scope="col"
				[ngClass]="{'cds--table-expand-v2': stickyHeader}"
				[id]="model.getId('expand')">
			</th>
			<th
				*ngIf="!skeleton && showSelectionColumn && enableSingleSelect"
				scope="col"
				[id]="model.getId('select')">
				<!-- add width 0; since the carbon styles don't seem to constrain this headers width -->
			</th>
			<th
				cdsTableHeadCheckbox
				*ngIf="!skeleton && showSelectionColumn && !enableSingleSelect"
				scope="col"
				[checked]="selectAllCheckbox"
				[indeterminate]="selectAllCheckboxSomeSelected"
				[ariaLabel]="getCheckboxHeaderLabel()"
				[skeleton]="skeleton"
				[name]="model.getHeaderId('select')"
				(change)="onSelectAllCheckboxChange()"
				[id]="model.getId('select')">
			</th>
			<ng-container *ngFor="let column of model.header; let i = index">
				<th
					*ngIf="column && column.visible"
					[ngStyle]="column.style"
					cdsTableHeadCell
					scope="col"
					[class]="column.className"
					[sortable]="sortable"
					[skeleton]="skeleton"
					[id]="model.getId(i)"
					[column]="column"
					[filterTitle]="getFilterTitle()"
					[attr.colspan]="column.colSpan"
					[attr.rowspan]="column.rowSpan"
					(sort)="sort.emit(i)">
				</th>
			</ng-container>
			<th *ngIf="!skeleton && stickyHeader && scrollbarWidth"
				scope="col"
				[ngStyle]="{'width': scrollbarWidth + 'px', 'padding': 0, 'border': 0}">
				<!--
					Scrollbar pushes body to the left so this header column is added to push
					the title bar the same amount and keep the header and body columns aligned.
				-->
			</th>
		</tr>
	</ng-container>
	<ng-content></ng-content>
	`, styles: [".cds--table-expand-v2{padding-left:2.5rem}\n"] }]
        }], ctorParameters: function () { return [{ type: i1.I18n }]; }, propDecorators: { model: [{
                type: Input
            }], showSelectionColumn: [{
                type: Input
            }], enableSingleSelect: [{
                type: Input
            }], selectAllCheckboxSomeSelected: [{
                type: Input
            }], selectAllCheckbox: [{
                type: Input
            }], skeleton: [{
                type: Input
            }], stickyHeader: [{
                type: Input
            }], sortable: [{
                type: Input
            }], checkboxHeaderLabel: [{
                type: Input
            }], sortDescendingLabel: [{
                type: Input
            }], sortAscendingLabel: [{
                type: Input
            }], filterTitle: [{
                type: Input
            }], sort: [{
                type: Output
            }], selectAll: [{
                type: Output
            }], deselectAll: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtaGVhZC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvdGFibGUvaGVhZC90YWJsZS1oZWFkLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUVaLE1BQU0sZUFBZSxDQUFDO0FBR3ZCLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlDQUFpQyxDQUFDOzs7Ozs7O0FBS3BFOzs7Ozs7OztHQVFHO0FBbUVILE1BQU0sT0FBTyxTQUFTO0lBaUZyQixZQUFzQixJQUFVO1FBQVYsU0FBSSxHQUFKLElBQUksQ0FBTTtRQTlFdkIsd0JBQW1CLEdBQUcsSUFBSSxDQUFDO1FBRTNCLHVCQUFrQixHQUFHLEtBQUssQ0FBQztRQUUzQixrQ0FBNkIsR0FBRyxLQUFLLENBQUM7UUFFdEMsc0JBQWlCLEdBQUcsS0FBSyxDQUFDO1FBRTFCLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFFakIsaUJBQVksR0FBRyxLQUFLLENBQUM7UUFFOUI7OztXQUdHO1FBQ00sYUFBUSxHQUFHLElBQUksQ0FBQztRQXNDekI7O1dBRUc7UUFDTyxTQUFJLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQUM1Qzs7OztXQUlHO1FBQ08sY0FBUyxHQUFHLElBQUksWUFBWSxFQUFjLENBQUM7UUFDckQ7Ozs7V0FJRztRQUNPLGdCQUFXLEdBQUcsSUFBSSxZQUFZLEVBQWMsQ0FBQztRQUVoRCxtQkFBYyxHQUFHLENBQUMsQ0FBQztRQUVoQix5QkFBb0IsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1FBQ3pFLHlCQUFvQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLHVCQUF1QixDQUFDLENBQUM7UUFDekUsd0JBQW1CLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxj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Z0JBVUYsV0FBVztzQkFEZCxLQUFLO2dCQVlJLElBQUk7c0JBQWIsTUFBTTtnQkFNRyxTQUFTO3NCQUFsQixNQUFNO2dCQU1HLFdBQVc7c0JBQXBCLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRDb21wb25lbnQsXG5cdElucHV0LFxuXHRPdXRwdXQsXG5cdEV2ZW50RW1pdHRlcixcblx0QWZ0ZXJWaWV3SW5pdFxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuXG5pbXBvcnQgeyBUYWJsZU1vZGVsIH0gZnJvbSBcIi4uL3RhYmxlLW1vZGVsLmNsYXNzXCI7XG5pbXBvcnQgeyBnZXRTY3JvbGxiYXJXaWR0aCB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL3V0aWxzXCI7XG5pbXBvcnQgeyBJMThuLCBPdmVycmlkYWJsZSB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2kxOG5cIjtcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tIFwicnhqc1wiO1xuaW1wb3J0IHsgVGFibGVSb3dTaXplIH0gZnJvbSBcIi4uL3RhYmxlLnR5cGVzXCI7XG5cbi8qKlxuICogQSBzdWJjb21wb25lbnQgdGhhdCBjcmVhdGVzIHRoZSB0aGVhZCBvZiB0aGUgdGFibGVcbiAqXG4gKiAjIyBCYXNpYyB1c2FnZVxuICpcbiAqIGBgYGh0bWxcbiAqIFx0PHRoZWFkIGNkc1RhYmxlSGVhZCBbbW9kZWxdPVwibW9kZWxcIj48L3RoZWFkPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuXHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Y29tcG9uZW50LXNlbGVjdG9yXG5cdHNlbGVjdG9yOiBcIltjZHNUYWJsZUhlYWRdLCBbaWJtVGFibGVIZWFkXVwiLFxuXHR0ZW1wbGF0ZTogYFxuXHQ8bmctY29udGFpbmVyICpuZ0lmPVwibW9kZWxcIj5cblx0XHQ8dHI+XG5cdFx0XHQ8dGhcblx0XHRcdFx0Y2RzVGFibGVIZWFkRXhwYW5kXG5cdFx0XHRcdCpuZ0lmPVwibW9kZWwuaGFzRXhwYW5kYWJsZVJvd3MoKVwiXG5cdFx0XHRcdHNjb3BlPVwiY29sXCJcblx0XHRcdFx0W25nQ2xhc3NdPVwieydjZHMtLXRhYmxlLWV4cGFuZC12Mic6IHN0aWNreUhlYWRlcn1cIlxuXHRcdFx0XHRbaWRdPVwibW9kZWwuZ2V0SWQoJ2V4cGFuZCcpXCI+XG5cdFx0XHQ8L3RoPlxuXHRcdFx0PHRoXG5cdFx0XHRcdCpuZ0lmPVwiIXNrZWxldG9uICYmIHNob3dTZWxlY3Rpb25Db2x1bW4gJiYgZW5hYmxlU2luZ2xlU2VsZWN0XCJcblx0XHRcdFx0c2NvcGU9XCJjb2xcIlxuXHRcdFx0XHRbaWRdPVwibW9kZWwuZ2V0SWQoJ3NlbGVjdCcpXCI+XG5cdFx0XHRcdDwhLS0gYWRkIHdpZHRoIDA7IHNpbmNlIHRoZSBjYXJib24gc3R5bGVzIGRvbid0IHNlZW0gdG8gY29uc3RyYWluIHRoaXMgaGVhZGVycyB3aWR0aCAtLT5cblx0XHRcdDwvdGg+XG5cdFx0XHQ8dGhcblx0XHRcdFx0Y2RzVGFibGVIZWFkQ2hlY2tib3hcblx0XHRcdFx0Km5nSWY9XCIhc2tlbGV0b24gJiYgc2hvd1NlbGVjdGlvbkNvbHVtbiAmJiAhZW5hYmxlU2luZ2xlU2VsZWN0XCJcblx0XHRcdFx0c2NvcGU9XCJjb2xcIlxuXHRcdFx0XHRbY2hlY2tlZF09XCJzZWxlY3RBbGxDaGVja2JveFwiXG5cdFx0XHRcdFtpbmRldGVybWluYXRlXT1cInNlbGVjdEFsbENoZWNrYm94U29tZVNlbGVjdGVkXCJcblx0XHRcdFx0W2FyaWFMYWJlbF09XCJnZXRDaGVja2JveEhlYWRlckxhYmVsKClcIlxuXHRcdFx0XHRbc2tlbGV0b25dPVwic2tlbGV0b25cIlxuXHRcdFx0XHRbbmFtZV09XCJtb2RlbC5nZXRIZWFkZXJJZCgnc2VsZWN0JylcIlxuXHRcdFx0XHQoY2hhbmdlKT1cIm9uU2VsZWN0QWxsQ2hlY2tib3hDaGFuZ2UoKVwiXG5cdFx0XHRcdFtpZF09XCJtb2RlbC5nZXRJZCgnc2VsZWN0JylcIj5cblx0XHRcdDwvdGg+XG5cdFx0XHQ8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgbW9kZWwuaGVhZGVyOyBsZXQgaSA9IGluZGV4XCI+XG5cdFx0XHRcdDx0aFxuXHRcdFx0XHRcdCpuZ0lmPVwiY29sdW1uICYmIGNvbHVtbi52aXNpYmxlXCJcblx0XHRcdFx0XHRbbmdTdHlsZV09XCJjb2x1bW4uc3R5bGVcIlxuXHRcdFx0XHRcdGNkc1RhYmxlSGVhZENlbGxcblx0XHRcdFx0XHRzY29wZT1cImNvbFwiXG5cdFx0XHRcdFx0W2NsYXNzXT1cImNvbHVtbi5jbGFzc05hbWVcIlxuXHRcdFx0XHRcdFtzb3J0YWJsZV09XCJzb3J0YWJsZVwiXG5cdFx0XHRcdFx0W3NrZWxldG9uXT1cInNrZWxldG9uXCJcblx0XHRcdFx0XHRbaWRdPVwibW9kZWwuZ2V0SWQoaSlcIlxuXHRcdFx0XHRcdFtjb2x1bW5dPVwiY29sdW1uXCJcblx0XHRcdFx0XHRbZmlsdGVyVGl0bGVdPVwiZ2V0RmlsdGVyVGl0bGUoKVwiXG5cdFx0XHRcdFx0W2F0dHIuY29sc3Bhbl09XCJjb2x1bW4uY29sU3BhblwiXG5cdFx0XHRcdFx0W2F0dHIucm93c3Bhbl09XCJjb2x1bW4ucm93U3BhblwiXG5cdFx0XHRcdFx0KHNvcnQpPVwic29ydC5lbWl0KGkpXCI+XG5cdFx0XHRcdDwvdGg+XG5cdFx0XHQ8L25nLWNvbnRhaW5lcj5cblx0XHRcdDx0aCAqbmdJZj1cIiFza2VsZXRvbiAmJiBzdGlja3lIZWFkZXIgJiYgc2Nyb2xsYmFyV2lkdGhcIlxuXHRcdFx0XHRzY29wZT1cImNvbFwiXG5cdFx0XHRcdFtuZ1N0eWxlXT1cInsnd2lkdGgnOiBzY3JvbGxiYXJXaWR0aCArICdweCcsICdwYWRkaW5nJzogMCwgJ2JvcmRlcic6IDB9XCI+XG5cdFx0XHRcdDwhLS1cblx0XHRcdFx0XHRTY3JvbGxiYXIgcHVzaGVzIGJvZHkgdG8gdGhlIGxlZnQgc28gdGhpcyBoZWFkZXIgY29sdW1uIGlzIGFkZGVkIHRvIHB1c2hcblx0XHRcdFx0XHR0aGUgdGl0bGUgYmFyIHRoZSBzYW1lIGFtb3VudCBhbmQga2VlcCB0aGUgaGVhZGVyIGFuZCBib2R5IGNvbHVtbnMgYWxpZ25lZC5cblx0XHRcdFx0LS0+XG5cdFx0XHQ8L3RoPlxuXHRcdDwvdHI+XG5cdDwvbmctY29udGFpbmVyPlxuXHQ8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG5cdGAsXG5cdHN0eWxlczogW2Bcblx0XHQuY2RzLS10YWJsZS1leHBhbmQtdjIge1xuXHRcdFx0cGFkZGluZy1sZWZ0OiAyLjVyZW07XG5cdFx0fVxuXHRgXVxufSlcbmV4cG9ydCBjbGFzcyBUYWJsZUhlYWQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcblx0QElucHV0KCkgbW9kZWw6IFRhYmxlTW9kZWw7XG5cblx0QElucHV0KCkgc2hvd1NlbGVjdGlvbkNvbHVtbiA9IHRydWU7XG5cblx0QElucHV0KCkgZW5hYmxlU2luZ2xlU2VsZWN0ID0gZmFsc2U7XG5cblx0QElucHV0KCkgc2VsZWN0QWxsQ2hlY2tib3hTb21lU2VsZWN0ZWQgPSBmYWxzZTtcblxuXHRASW5wdXQoKSBzZWxlY3RBbGxDaGVja2JveCA9IGZhbHNlO1xuXG5cdEBJbnB1dCgpIHNrZWxldG9uID0gZmFsc2U7XG5cblx0QElucHV0KCkgc3RpY2t5SGVhZGVyID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFNldHRpbmcgc29ydGFibGUgdG8gZmFsc2Ugd2lsbCBkaXNhYmxlIGFsbCBoZWFkZXJzIGluY2x1ZGluZyBoZWFkZXJzIHdoaWNoIGFyZSBzb3J0YWJsZS4gSXMgaXNcblx0ICogcG9zc2libGUgdG8gc2V0IHRoZSBzb3J0YWJsZSBzdGF0ZSBvbiB0aGUgaGVhZGVyIGl0ZW0gdG8gZGlzYWJsZS9lbmFibGUgc29ydGluZyBmb3Igb25seSBzb21lIGhlYWRlcnMuXG5cdCAqL1xuXHRASW5wdXQoKSBzb3J0YWJsZSA9IHRydWU7XG5cblx0QElucHV0KClcblx0c2V0IGNoZWNrYm94SGVhZGVyTGFiZWwodmFsdWU6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPikge1xuXHRcdHRoaXMuX2NoZWNrYm94SGVhZGVyTGFiZWwub3ZlcnJpZGUodmFsdWUpO1xuXHR9XG5cblx0Z2V0IGNoZWNrYm94SGVhZGVyTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrYm94SGVhZGVyTGFiZWwudmFsdWU7XG5cdH1cblxuXHRASW5wdXQoKVxuXHRzZXQgc29ydERlc2NlbmRpbmdMYWJlbCh2YWx1ZTogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+KSB7XG5cdFx0dGhpcy5fc29ydERlc2NlbmRpbmdMYWJlbC5vdmVycmlkZSh2YWx1ZSk7XG5cdH1cblxuXHRnZXQgc29ydERlc2NlbmRpbmdMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc29ydERlc2NlbmRpbmdMYWJlbC52YWx1ZTtcblx0fVxuXG5cdEBJbnB1dCgpXG5cdHNldCBzb3J0QXNjZW5kaW5nTGFiZWwodmFsdWU6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPikge1xuXHRcdHRoaXMuX3NvcnRBc2NlbmRpbmdMYWJlbC5vdmVycmlkZSh2YWx1ZSk7XG5cdH1cblxuXHRnZXQgc29ydEFzY2VuZGluZ0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9zb3J0QXNjZW5kaW5nTGFiZWwudmFsdWU7XG5cdH1cblxuXHRASW5wdXQoKVxuXHRzZXQgZmlsdGVyVGl0bGUodmFsdWU6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPikge1xuXHRcdHRoaXMuX2ZpbHRlclRpdGxlLm92ZXJyaWRlKHZhbHVlKTtcblx0fVxuXG5cdGdldCBmaWx0ZXJUaXRsZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZmlsdGVyVGl0bGUudmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogRW1pdHMgYW4gaW5kZXggb2YgdGhlIGNvbHVtbiB0aGF0IHdhbnRzIHRvIGJlIHNvcnRlZC5cblx0ICovXG5cdEBPdXRwdXQoKSBzb3J0ID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cdC8qKlxuXHQgKiBFbWl0cyBpZiBhbGwgcm93cyBhcmUgc2VsZWN0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSBtb2RlbFxuXHQgKi9cblx0QE91dHB1dCgpIHNlbGVjdEFsbCA9IG5ldyBFdmVudEVtaXR0ZXI8VGFibGVNb2RlbD4oKTtcblx0LyoqXG5cdCAqIEVtaXRzIGlmIGFsbCByb3dzIGFyZSBkZXNlbGVjdGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0gbW9kZWxcblx0ICovXG5cdEBPdXRwdXQoKSBkZXNlbGVjdEFsbCA9IG5ldyBFdmVudEVtaXR0ZXI8VGFibGVNb2RlbD4oKTtcblxuXHRwdWJsaWMgc2Nyb2xsYmFyV2lkdGggPSAwO1xuXG5cdHByb3RlY3RlZCBfY2hlY2tib3hIZWFkZXJMYWJlbCA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRBQkxFLkNIRUNLQk9YX0hFQURFUlwiKTtcblx0cHJvdGVjdGVkIF9zb3J0RGVzY2VuZGluZ0xhYmVsID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuU09SVF9ERVNDRU5ESU5HXCIpO1xuXHRwcm90ZWN0ZWQgX3NvcnRBc2NlbmRpbmdMYWJlbCA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRBQkxFLlNPUlRfQVNDRU5ESU5HXCIpO1xuXHRwcm90ZWN0ZWQgX2ZpbHRlclRpdGxlID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuRklMVEVSXCIpO1xuXG5cdGNvbnN0cnVjdG9yKHByb3RlY3RlZCBpMThuOiBJMThuKSB7fVxuXG5cdG5nQWZ0ZXJWaWV3SW5pdCgpIHtcblx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdHRoaXMuc2Nyb2xsYmFyV2lkdGggPSBnZXRTY3JvbGxiYXJXaWR0aCgpO1xuXHRcdH0pO1xuXHR9XG5cblx0b25TZWxlY3RBbGxDaGVja2JveENoYW5nZSgpIHtcblx0XHRpZiAoIXRoaXMuc2VsZWN0QWxsQ2hlY2tib3ggJiYgIXRoaXMuc2VsZWN0QWxsQ2hlY2tib3hTb21lU2VsZWN0ZWQpIHtcblx0XHRcdHRoaXMuc2VsZWN0QWxsLmVtaXQodGhpcy5tb2RlbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZGVzZWxlY3RBbGwuZW1pdCh0aGlzLm1vZGVsKTtcblx0XHR9XG5cdH1cblxuXHRnZXRDaGVja2JveEhlYWRlckxhYmVsKCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrYm94SGVhZGVyTGFiZWwuc3ViamVjdDtcblx0fVxuXG5cdGdldFNvcnREZXNjZW5kaW5nTGFiZWwoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblx0XHRyZXR1cm4gdGhpcy5fc29ydERlc2NlbmRpbmdMYWJlbC5zdWJqZWN0O1xuXHR9XG5cblx0Z2V0U29ydEFzY2VuZGluZ0xhYmVsKCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvcnRBc2NlbmRpbmdMYWJlbC5zdWJqZWN0O1xuXHR9XG5cblx0Z2V0RmlsdGVyVGl0bGUoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblx0XHRyZXR1cm4gdGhpcy5fZmlsdGVyVGl0bGUuc3ViamVjdDtcblx0fVxufVxuIl19