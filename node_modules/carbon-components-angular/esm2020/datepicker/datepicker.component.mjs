import { Component, Input, Output, EventEmitter, ViewEncapsulation, HostListener, ViewChild } from "@angular/core";
import rangePlugin from "flatpickr/dist/plugins/rangePlugin";
import flatpickr from "flatpickr";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
import { carbonFlatpickrMonthSelectPlugin } from "./carbon-flatpickr-month-select";
import * as languages from "flatpickr/dist/l10n/index";
import * as i0 from "@angular/core";
import * as i1 from "carbon-components-angular/i18n";
import * as i2 from "@angular/common";
import * as i3 from "carbon-components-angular/datepicker-input";
/**
 * Due to type error, we have to use square brackets property accessor
 * There is a webpack issue when attempting to access exported languages from flatpickr l10n Angular 14+ apps
 * languages.default[locale] fails in app consuming CCA library but passes in test
 * languages.default.default[locale] fails in test but works in app consuming CCA library.
 *
 * To please both scenarios, we are adding a condition to prevent tests from failing
 */
if (languages.default?.default["en"]?.weekdays) {
    languages.default.default["en"].weekdays.shorthand = languages.default.default["en"].weekdays.longhand.map(day => {
        if (day === "Thursday") {
            return "Th";
        }
        return day.charAt(0);
    });
}
/**
 * Get started with importing the module:
 *
 * ```typescript
 * import { DatePickerModule } from 'carbon-components-angular';
 * ```
 *
 * [See demo](../../?path=/story/components-date-picker--single)
 */
export class DatePicker {
    constructor(elementRef, i18n) {
        this.elementRef = elementRef;
        this.i18n = i18n;
        /**
         * Select calendar range mode
         */
        this.range = false;
        /**
         * Format of date
         *
         * For reference: https://flatpickr.js.org/formatting/
         */
        this.dateFormat = "m/d/Y";
        /**
         * Language of the flatpickr calendar.
         *
         * For reference of the possible locales:
         * https://github.com/flatpickr/flatpickr/blob/master/src/l10n/index.ts
         */
        this.language = "en";
        this.placeholder = "mm/dd/yyyy";
        /**
         * Aria label added to datepicker's calendar container.
         */
        this.ariaLabel = "calendar container";
        /**
         * The pattern for the underlying input element
         */
        this.inputPattern = "^\\d{1,2}/\\d{1,2}/\\d{4}$";
        this.id = `datepicker-${DatePicker.datePickerCount++}`;
        /**
         * @deprecated since v5 - Use `cdsLayer` directive instead
         * Set to `"light"` to apply the light style
         */
        this.theme = "dark";
        this.disabled = false;
        /**
         * Set to `true` to display the invalid state.
         */
        this.invalid = false;
        /**
          * Set to `true` to show a warning (contents set by warningText)
          */
        this.warn = false;
        this.size = "md";
        /**
         * Set to `true` to display the invalid state for the second datepicker input.
         */
        this.rangeInvalid = false;
        /**
          * Set to `true` to show a warning in the second datepicker input (contents set by rangeWarningText)
          */
        this.rangeWarn = false;
        this.skeleton = false;
        this.plugins = [];
        this.valueChange = new EventEmitter();
        /**
         * We are overriding onClose event even if users pass it via flatpickr options
         * Emits an event when date picker closes
         */
        this.onClose = new EventEmitter();
        this._value = [];
        this._flatpickrOptions = {
            allowInput: true
        };
        this.flatpickrBaseOptions = {
            mode: "single",
            dateFormat: "m/d/Y",
            plugins: this.plugins,
            onOpen: () => {
                this.updateClassNames();
                this.updateAttributes();
                this.updateCalendarListeners();
            },
            onClose: (date) => {
                // This makes sure that the `flatpickrInstance selectedDates` are in sync with the values of
                // the inputs when the calendar closes.
                if (this.range && this.flatpickrInstance) {
                    const inputValue = this.input.input.nativeElement.value;
                    const rangeInputValue = this.rangeInput.input.nativeElement.value;
                    if (inputValue || rangeInputValue) {
                        const parseDate = (date) => this.flatpickrInstance.parseDate(date, this.dateFormat);
                        this.setDateValues([parseDate(inputValue), parseDate(rangeInputValue || inputValue)]);
                        this.doSelect(this.flatpickrInstance.selectedDates);
                    }
                }
                this.onClose.emit(date);
            },
            onDayCreate: (_dObj, _dStr, _fp, dayElem) => {
                dayElem.classList.add("cds--date-picker__day");
            },
            nextArrow: this.rightArrowHTML(),
            prevArrow: this.leftArrowHTML(),
            value: this.value
        };
        this.flatpickrInstance = null;
        this.onTouched = () => { };
        this.propagateChange = (_) => { };
        this.preventCalendarClose = event => event.stopPropagation();
    }
    set value(v) {
        if (!v) {
            v = [];
        }
        this._value = v;
    }
    get value() {
        return this._value;
    }
    set flatpickrOptions(options) {
        this._flatpickrOptions = Object.assign({}, this._flatpickrOptions, options);
    }
    get flatpickrOptions() {
        const plugins = [...this.plugins, carbonFlatpickrMonthSelectPlugin];
        if (this.range) {
            plugins.push(rangePlugin({ input: `#${this.id}-rangeInput`, position: "left" }));
        }
        return Object.assign({}, this._flatpickrOptions, this.flatpickrBaseOptions, {
            mode: this.range ? "range" : "single",
            plugins,
            dateFormat: this.dateFormat,
            locale: languages.default?.default[this.language] || languages.default[this.language]
        });
    }
    ngOnInit() {
        // if i18n is set to anything other than en we'll want to change the language
        // otherwise we'll just use the local setting
        if (this.i18n.getLocale() !== "en") {
            this.i18n.getLocaleObservable().subscribe(locale => {
                this.language = locale;
                this.resetFlatpickrInstance();
            });
        }
    }
    ngOnChanges(changes) {
        // Reset the flatpickr instance on input changes that affect flatpickr.
        const flatpickrChangeKeys = [
            "range",
            "dateFormat",
            "language",
            "id",
            "value",
            "plugins",
            "flatpickrOptions"
        ];
        const changeKeys = Object.keys(changes);
        if (changeKeys.some(key => flatpickrChangeKeys.includes(key))) {
            this.resetFlatpickrInstance(changes.value);
        }
    }
    ngAfterViewInit() {
        this.input.input.nativeElement.value = this._value[0] ?? "";
        if (this.range) {
            this.rangeInput.input.nativeElement.value = this._value[1] ?? "";
        }
        setTimeout(() => {
            this.addInputListeners();
        }, 0);
    }
    // because the actual view may be delayed in loading (think projection into a tab pane)
    // and because we rely on a library that operates outside the Angular view of the world
    // we need to keep trying to load the library, until the relevant DOM is actually live
    ngAfterViewChecked() {
        if (!this.isFlatpickrLoaded()) {
            // @ts-ignore ts is unhappy with the below call to `flatpickr`
            this.flatpickrInstance = flatpickr(`#${this.id}-input`, this.flatpickrOptions);
            // if (and only if) the initialization succeeded, we can set the date values
            if (this.isFlatpickrLoaded()) {
                if (this.value.length > 0) {
                    this.setDateValues(this.value);
                }
            }
        }
    }
    onFocus() {
        // Updates the month manually when calendar mode is range because month
        // will not update properly without manually updating them on focus.
        if (this.range) {
            if (this.rangeInput.input.nativeElement === document.activeElement && this.flatpickrInstance.selectedDates[1]) {
                const currentMonth = this.flatpickrInstance.selectedDates[1].getMonth();
                this.flatpickrInstance.changeMonth(currentMonth, false);
            }
            else if (this.input.input.nativeElement === document.activeElement && this.flatpickrInstance.selectedDates[0]) {
                const currentMonth = this.flatpickrInstance.selectedDates[0].getMonth();
                this.flatpickrInstance.changeMonth(currentMonth, false);
            }
        }
    }
    onFocusOut() {
        this.onTouched();
    }
    /**
     * Writes a value from the model to the component. Expects the value to be `null` or `(Date | string)[]`
     * @param value value received from the model
     */
    writeValue(value) {
        this.value = value;
        setTimeout(() => {
            if (this.isFlatpickrLoaded() && this.flatpickrInstance.config) {
                this.setDateValues(this.value);
            }
        });
    }
    /**
     * `ControlValueAccessor` method to programmatically disable the DatePicker.
     *
     * ex: `this.formGroup.get("myDatePicker").disable();`
     *
     * @param isDisabled `true` to disable the DatePicker
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * Cleans up our flatpickr instance
     */
    ngOnDestroy() {
        if (!this.isFlatpickrLoaded()) {
            return;
        }
        this.flatpickrInstance.destroy();
    }
    /**
     * Handles the `valueChange` event from the primary/single input
     */
    onValueChange(event) {
        if (this.isFlatpickrLoaded()) {
            const date = this.flatpickrInstance.parseDate(event, this.dateFormat);
            if (this.range) {
                this.setDateValues([date, this.flatpickrInstance.selectedDates[1]]);
            }
            else {
                this.setDateValues([date]);
            }
            this.doSelect(this.flatpickrInstance.selectedDates);
        }
    }
    /**
     * Handles the `valueChange` event from the range input
     */
    onRangeValueChange(event) {
        if (this.isFlatpickrLoaded() && this.flatpickrInstance.isOpen) {
            const date = this.flatpickrInstance.parseDate(event, this.dateFormat);
            this.setDateValues([this.flatpickrInstance.selectedDates[0], date]);
            this.doSelect(this.flatpickrInstance.selectedDates);
        }
    }
    /**
     * Handles opening the calendar "properly" when the calendar icon is clicked.
     */
    openCalendar(datepickerInput) {
        if (this.range) {
            datepickerInput.input.nativeElement.click();
            // If the first input's calendar icon is clicked when calendar is in range mode, then
            // the month and year needs to be manually changed to the current selected month and
            // year otherwise the calendar view will not be updated upon opening.
            if (datepickerInput === this.input && this.flatpickrInstance.selectedDates[0]) {
                const currentMonth = this.flatpickrInstance.selectedDates[0].getMonth();
                this.flatpickrInstance.currentYear = this.flatpickrInstance.selectedDates[0].getFullYear();
                this.flatpickrInstance.changeMonth(currentMonth, false);
            }
        }
        else {
            // Single-mode flatpickr handles mousedown but not click, so nativeElement.click() won't
            // work when the calendar icon is clicked. In this case we simply use flatpickr.open().
            this.flatpickrInstance.open();
        }
    }
    updateCalendarListeners() {
        const calendarContainer = document.querySelectorAll(".flatpickr-calendar");
        Array.from(calendarContainer).forEach(calendar => {
            calendar.removeEventListener("click", this.preventCalendarClose);
            calendar.addEventListener("click", this.preventCalendarClose);
        });
    }
    /**
     * Handles the initialization of event listeners for the datepicker input and range input fields.
     */
    addInputListeners() {
        if (!this.isFlatpickrLoaded()) {
            return;
        }
        // Allows focus transition from the datepicker input or range input field to
        // flatpickr calendar using a keyboard.
        const addFocusCalendarListener = (element) => {
            element.addEventListener("keydown", (event) => {
                if (event.key === "Escape") {
                    this.flatpickrInstance.close();
                }
                if (event.key === "ArrowDown") {
                    if (!this.flatpickrInstance.isOpen) {
                        this.flatpickrInstance.open();
                    }
                    const calendarContainer = this.flatpickrInstance.calendarContainer;
                    const dayElement = calendarContainer && calendarContainer.querySelector(".flatpickr-day[tabindex]");
                    if (dayElement) {
                        dayElement.focus();
                        // If the user manually inputs a value into the date field and presses arrow down,
                        // datepicker input onchange will be triggered when focus is removed from it and
                        // `flatpickrInstance.setDate` and `flatpickrInstance.changeMonth` will be invoked
                        // which will automatically change focus to the beginning of the document.
                        if (document.activeElement !== dayElement && this.flatpickrInstance.selectedDateElem) {
                            this.flatpickrInstance.selectedDateElem.focus();
                        }
                    }
                }
            });
        };
        if (this.input && this.input.input) {
            addFocusCalendarListener(this.input.input.nativeElement);
        }
        if (this.rangeInput && this.rangeInput.input) {
            addFocusCalendarListener(this.rangeInput.input.nativeElement);
        }
    }
    /**
     * Resets the flatpickr instance while keeping the date values (or updating them if newDates is provided)
     *
     * Used to pick up input changes or locale changes.
     *
     * @param newDates An optional SimpleChange of date values
     */
    resetFlatpickrInstance(newDates) {
        if (this.isFlatpickrLoaded()) {
            let dates = this.flatpickrInstance.selectedDates;
            if (newDates && this.didDateValueChange(newDates.currentValue, newDates.previousValue)) {
                dates = newDates.currentValue;
            }
            // only reset the flatpickr instance on Input changes
            // @ts-ignore ts is unhappy with the below call to `flatpickr`
            this.flatpickrInstance = flatpickr(`#${this.id}-input`, this.flatpickrOptions);
            this.setDateValues(dates);
        }
    }
    /**
     * Carbon uses a number of specific classnames for parts of the flatpickr - this idempotent method applies them if needed.
     */
    updateClassNames() {
        if (!this.elementRef) {
            return;
        }
        // get all the possible flatpickrs in the document - we need to add classes to (potentially) all of them
        const calendarContainer = document.querySelectorAll(".flatpickr-calendar");
        const monthContainer = document.querySelectorAll(".flatpickr-month");
        const weekdaysContainer = document.querySelectorAll(".flatpickr-weekdays");
        const weekdayContainer = document.querySelectorAll(".flatpickr-weekday");
        const daysContainer = document.querySelectorAll(".flatpickr-days");
        const dayContainer = document.querySelectorAll(".flatpickr-day");
        // add classes to lists of elements
        const addClassIfNotExists = (classname, elementList) => {
            Array.from(elementList).forEach(element => {
                if (!element.classList.contains(classname)) {
                    element.classList.add(classname);
                }
            });
        };
        // add classes (but only if they don't exist, small perf win)
        addClassIfNotExists("cds--date-picker__calendar", calendarContainer);
        addClassIfNotExists("cds--date-picker__month", monthContainer);
        addClassIfNotExists("cds--date-picker__weekdays", weekdaysContainer);
        addClassIfNotExists("cds--date-picker__days", daysContainer);
        // add weekday classes and format the text
        Array.from(weekdayContainer).forEach(element => {
            element.innerHTML = element.innerHTML.replace(/\s+/g, "");
            element.classList.add("cds--date-picker__weekday");
        });
        // add day classes and special case the "today" element based on `this.value`
        Array.from(dayContainer).forEach(element => {
            element.classList.add("cds--date-picker__day");
            if (!this.value) {
                return;
            }
            if (element.classList.contains("today") && this.value.length > 0) {
                element.classList.add("no-border");
            }
            else if (element.classList.contains("today") && this.value.length === 0) {
                element.classList.remove("no-border");
            }
        });
    }
    updateAttributes() {
        const calendarContainer = document.querySelectorAll(".flatpickr-calendar");
        Array.from(calendarContainer).forEach(calendar => {
            calendar.setAttribute("role", "region");
            calendar.setAttribute("aria-label", this.ariaLabel);
        });
    }
    /**
     * Applies the given date value array to both the flatpickr instance and the `input`(s)
     * @param dates the date values to apply
     */
    setDateValues(dates) {
        if (this.isFlatpickrLoaded()) {
            const singleInput = this.elementRef.nativeElement.querySelector(`#${this.id}-input`);
            const rangeInput = this.elementRef.nativeElement.querySelector(`#${this.id}-rangeInput`);
            // `flatpickrInstance.setDate` removes the focus on the selected date element and will
            // automatically change focus to the beginning of the document. If a selected date is
            // focused before `flatpickrInstance.setDate` is invoked then it should remain focused.
            let shouldRefocusDateElement = this.flatpickrInstance.selectedDateElem === document.activeElement;
            // set the date on the instance
            this.flatpickrInstance.setDate(dates);
            if (shouldRefocusDateElement) {
                this.flatpickrInstance.selectedDateElem.focus();
            }
            // we can either set a date value or an empty string, so we start with an empty string
            let singleDate = "";
            // if date is a string, parse and format
            if (typeof this.flatpickrInstance.selectedDates[0] === "string") {
                singleDate = this.flatpickrInstance.parseDate(this.flatpickrInstance.selectedDates[0], this.dateFormat);
                singleDate = this.flatpickrInstance.formatDate(singleDate, this.dateFormat);
                // if date is not a string we can assume it's a Date and we should format
            }
            else if (!!this.flatpickrInstance.selectedDates[0]) {
                singleDate = this.flatpickrInstance.formatDate(this.flatpickrInstance.selectedDates[0], this.dateFormat);
            }
            if (rangeInput) {
                // we can either set a date value or an empty string, so we start with an empty string
                let rangeDate = "";
                // if date is a string, parse and format
                if (typeof this.flatpickrInstance.selectedDates[1] === "string") {
                    rangeDate = this.flatpickrInstance.parseDate(this.flatpickrInstance.selectedDates[1].toString(), this.dateFormat);
                    rangeDate = this.flatpickrInstance.formatDate(rangeDate, this.dateFormat);
                    // if date is not a string we can assume it's a Date and we should format
                }
                else if (!!this.flatpickrInstance.selectedDates[1]) {
                    rangeDate = this.flatpickrInstance.formatDate(this.flatpickrInstance.selectedDates[1], this.dateFormat);
                }
                setTimeout(() => {
                    // apply the values
                    rangeInput.value = rangeDate;
                    singleInput.value = singleDate;
                });
            }
        }
    }
    doSelect(selectedValue) {
        // In range mode, if a date is selected from the first calendar that is from the previous month,
        // the month will not be updated on the calendar until the calendar is re-opened.
        // This will make sure the calendar is updated with the correct month.
        if (this.range && this.flatpickrInstance.selectedDates[0]) {
            const currentMonth = this.flatpickrInstance.selectedDates[0].getMonth();
            // `flatpickrInstance.changeMonth` removes the focus on the selected date element and will
            // automatically change focus to the beginning of the document. If a selected date is
            // focused before `flatpickrInstance.changeMonth` is invoked then it should remain focused.
            let shouldRefocusDateElement = this.flatpickrInstance.selectedDateElem === document.activeElement;
            this.flatpickrInstance.changeMonth(currentMonth, false);
            if (shouldRefocusDateElement) {
                this.flatpickrInstance.selectedDateElem.focus();
            }
        }
        this.valueChange.emit(selectedValue);
        this.propagateChange(selectedValue);
    }
    didDateValueChange(currentValue, previousValue) {
        return currentValue[0] !== previousValue[0] || currentValue[1] !== previousValue[1];
    }
    /**
     * More advanced checking of the loaded state of flatpickr
     */
    isFlatpickrLoaded() {
        // cast the instance to a boolean, and some method that has to exist for the library to be loaded in this case `setDate`
        return !!this.flatpickrInstance && !!this.flatpickrInstance.setDate;
    }
    /**
     * Right arrow HTML passed to flatpickr
     */
    rightArrowHTML() {
        return `
			<svg width="16px" height="16px" viewBox="0 0 16 16">
				<polygon points="11,8 6,13 5.3,12.3 9.6,8 5.3,3.7 6,3 "/>
				<rect width="16" height="16" style="fill:none" />
			</svg>`;
    }
    /**
     * Left arrow HTML passed to flatpickr
     */
    leftArrowHTML() {
        return `
			<svg width="16px" height="16px" viewBox="0 0 16 16">
				<polygon points="5,8 10,3 10.7,3.7 6.4,8 10.7,12.3 10,13 "/>
				<rect width="16" height="16" style="fill:none" />
			</svg>`;
    }
}
DatePicker.datePickerCount = 0;
DatePicker.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DatePicker, deps: [{ token: i0.ElementRef }, { token: i1.I18n }], target: i0.ɵɵFactoryTarget.Component });
DatePicker.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: DatePicker, selector: "cds-date-picker, ibm-date-picker", inputs: { range: "range", dateFormat: "dateFormat", language: "language", label: "label", helperText: "helperText", rangeHelperText: "rangeHelperText", rangeLabel: "rangeLabel", placeholder: "placeholder", ariaLabel: "ariaLabel", inputPattern: "inputPattern", id: "id", value: "value", theme: "theme", disabled: "disabled", invalid: "invalid", invalidText: "invalidText", warn: "warn", warnText: "warnText", size: "size", rangeInvalid: "rangeInvalid", rangeInvalidText: "rangeInvalidText", rangeWarn: "rangeWarn", rangeWarnText: "rangeWarnText", skeleton: "skeleton", plugins: "plugins", flatpickrOptions: "flatpickrOptions" }, outputs: { valueChange: "valueChange", onClose: "onClose" }, host: { listeners: { "focusin": "onFocus()", "focusout": "onFocusOut()" } }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: DatePicker,
            multi: true
        }
    ], viewQueries: [{ propertyName: "input", first: true, predicate: ["input"], descendants: true, static: true }, { propertyName: "rangeInput", first: true, predicate: ["rangeInput"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
	<div class="cds--form-item">
		<div
			class="cds--date-picker"
			[ngClass]="{
				'cds--date-picker--range' : range,
				'cds--date-picker--single' : !range,
				'cds--date-picker--light' : theme === 'light',
				'cds--skeleton' : skeleton
			}">
			<div class="cds--date-picker-container">
				<cds-date-picker-input
					#input
					[label]="label"
					[placeholder]="placeholder"
					[pattern]="inputPattern"
					[id]="id + '-input'"
					[size]="size"
					[type]="(range ? 'range' : 'single')"
					[hasIcon]="(range ? false : true)"
					[disabled]="disabled"
					[invalid]="invalid"
					[invalidText]="invalidText"
					[warn]="warn"
					[warnText]="warnText"
					[skeleton]="skeleton"
					[helperText]="helperText"
					(valueChange)="onValueChange($event)"
					(click)="openCalendar(input)">
				</cds-date-picker-input>
			</div>

			<div *ngIf="range" class="cds--date-picker-container">
				<cds-date-picker-input
					#rangeInput
					[label]="rangeLabel"
					[placeholder]="placeholder"
					[pattern]="inputPattern"
					[id]="id + '-rangeInput'"
					[size]="size"
					[type]="(range ? 'range' : 'single')"
					[hasIcon]="(range ? true : null)"
					[disabled]="disabled"
					[invalid]="rangeInvalid"
					[invalidText]="rangeInvalidText"
					[warn]="rangeWarn"
					[warnText]="rangeWarnText"
					[skeleton]="skeleton"
					[helperText]="rangeHelperText"
					(valueChange)="onRangeValueChange($event)"
					(click)="openCalendar(rangeInput)">
				</cds-date-picker-input>
			</div>
		</div>
	</div>
	`, isInline: true, dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i3.DatePickerInput, selector: "cds-date-picker-input, ibm-date-picker-input", inputs: ["type", "id", "hasIcon", "label", "placeholder", "pattern", "theme", "disabled", "invalid", "invalidText", "warn", "warnText", "helperText", "skeleton", "value", "size"], outputs: ["valueChange"] }], encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DatePicker, decorators: [{
            type: Component,
            args: [{
                    selector: "cds-date-picker, ibm-date-picker",
                    template: `
	<div class="cds--form-item">
		<div
			class="cds--date-picker"
			[ngClass]="{
				'cds--date-picker--range' : range,
				'cds--date-picker--single' : !range,
				'cds--date-picker--light' : theme === 'light',
				'cds--skeleton' : skeleton
			}">
			<div class="cds--date-picker-container">
				<cds-date-picker-input
					#input
					[label]="label"
					[placeholder]="placeholder"
					[pattern]="inputPattern"
					[id]="id + '-input'"
					[size]="size"
					[type]="(range ? 'range' : 'single')"
					[hasIcon]="(range ? false : true)"
					[disabled]="disabled"
					[invalid]="invalid"
					[invalidText]="invalidText"
					[warn]="warn"
					[warnText]="warnText"
					[skeleton]="skeleton"
					[helperText]="helperText"
					(valueChange)="onValueChange($event)"
					(click)="openCalendar(input)">
				</cds-date-picker-input>
			</div>

			<div *ngIf="range" class="cds--date-picker-container">
				<cds-date-picker-input
					#rangeInput
					[label]="rangeLabel"
					[placeholder]="placeholder"
					[pattern]="inputPattern"
					[id]="id + '-rangeInput'"
					[size]="size"
					[type]="(range ? 'range' : 'single')"
					[hasIcon]="(range ? true : null)"
					[disabled]="disabled"
					[invalid]="rangeInvalid"
					[invalidText]="rangeInvalidText"
					[warn]="rangeWarn"
					[warnText]="rangeWarnText"
					[skeleton]="skeleton"
					[helperText]="rangeHelperText"
					(valueChange)="onRangeValueChange($event)"
					(click)="openCalendar(rangeInput)">
				</cds-date-picker-input>
			</div>
		</div>
	</div>
	`,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: DatePicker,
                            multi: true
                        }
                    ],
                    encapsulation: ViewEncapsulation.None
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1.I18n }]; }, propDecorators: { range: [{
                type: Input
            }], dateFormat: [{
                type: Input
            }], language: [{
                type: Input
            }], label: [{
                type: Input
            }], helperText: [{
                type: Input
            }], rangeHelperText: [{
                type: Input
            }], rangeLabel: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], ariaLabel: [{
                type: Input
            }], inputPattern: [{
                type: Input
            }], id: [{
                type: Input
            }], value: [{
                type: Input
            }], theme: [{
                type: Input
            }], disabled: [{
                type: Input
            }], invalid: [{
                type: Input
            }], invalidText: [{
                type: Input
            }], warn: [{
                type: Input
            }], warnText: [{
                type: Input
            }], size: [{
                type: Input
            }], rangeInvalid: [{
                type: Input
            }], rangeInvalidText: [{
                type: Input
            }], rangeWarn: [{
                type: Input
            }], rangeWarnText: [{
                type: Input
            }], skeleton: [{
                type: Input
            }], plugins: [{
                type: Input
            }], flatpickrOptions: [{
                type: Input
            }], input: [{
                type: ViewChild,
                args: ["input", { static: true }]
            }], rangeInput: [{
                type: ViewChild,
                args: ["rangeInput"]
            }], valueChange: [{
                type: Output
            }], onClose: [{
                type: Output
            }], onFocus: [{
                type: HostListener,
                args: ["focusin"]
            }], onFocusOut: [{
                type: HostListener,
                args: ["focusout"]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvZGF0ZXBpY2tlci9kYXRlcGlja2VyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLGlCQUFpQixFQUdqQixZQUFZLEVBTVosU0FBUyxFQUdULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sV0FBVyxNQUFNLG9DQUFvQyxDQUFDO0FBQzdELE9BQU8sU0FBUyxNQUFNLFdBQVcsQ0FBQztBQUNsQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNuRCxPQUFPLEVBQUUsZ0NBQWdDLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUNuRixPQUFPLEtBQUssU0FBUyxNQUFNLDJCQUEyQixDQUFDOzs7OztBQUt2RDs7Ozs7OztHQU9HO0FBQ0gsSUFBSSxTQUFTLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxRQUFRLEVBQUU7SUFDOUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLFNBQXNCLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDOUgsSUFBSSxHQUFHLEtBQUssVUFBVSxFQUFFO1lBQ3ZCLE9BQU8sSUFBSSxDQUFDO1NBQ1o7UUFDRCxPQUFPLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEIsQ0FBQyxDQUFDLENBQUM7Q0FDSDtBQUVEOzs7Ozs7OztHQVFHO0FBb0VILE1BQU0sT0FBTyxVQUFVO0lBMkt0QixZQUNXLFVBQXNCLEVBQ3RCLElBQVU7UUFEVixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQ3RCLFNBQUksR0FBSixJQUFJLENBQU07UUFyS3JCOztXQUVHO1FBQ00sVUFBSyxHQUFHLEtBQUssQ0FBQztRQUV2Qjs7OztXQUlHO1FBQ00sZUFBVSxHQUFHLE9BQU8sQ0FBQztRQUU5Qjs7Ozs7V0FLRztRQUNNLGFBQVEsR0FBRyxJQUFJLENBQUM7UUFPaEIsZ0JBQVcsR0FBRyxZQUFZLENBQUM7UUFFcEM7O1dBRUc7UUFDTSxjQUFTLEdBQUcsb0JBQW9CLENBQUM7UUFFMUM7O1dBRUc7UUFDTSxpQkFBWSxHQUFHLDRCQUE0QixDQUFDO1FBRTVDLE9BQUUsR0FBRyxjQUFjLFVBQVUsQ0FBQyxlQUFlLEVBQUUsRUFBRSxDQUFDO1FBYTNEOzs7V0FHRztRQUNNLFVBQUssR0FBcUIsTUFBTSxDQUFDO1FBRWpDLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFDMUI7O1dBRUc7UUFDTSxZQUFPLEdBQUcsS0FBSyxDQUFDO1FBS3pCOztZQUVJO1FBQ0ssU0FBSSxHQUFHLEtBQUssQ0FBQztRQU1iLFNBQUksR0FBdUIsSUFBSSxDQUFDO1FBQ3pDOztXQUVHO1FBQ00saUJBQVksR0FBRyxLQUFLLENBQUM7UUFLOUI7O1lBRUk7UUFDSyxjQUFTLEdBQUcsS0FBSyxDQUFDO1FBTWxCLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFFakIsWUFBTyxHQUFHLEVBQUUsQ0FBQztRQXNCWixnQkFBVyxHQUFzQixJQUFJLFlBQVksRUFBRSxDQUFDO1FBRTlEOzs7V0FHRztRQUNPLFlBQU8sR0FBc0IsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUVoRCxXQUFNLEdBQUcsRUFBRSxDQUFDO1FBRVosc0JBQWlCLEdBQXFCO1lBQy9DLFVBQVUsRUFBRSxJQUFJO1NBQ2hCLENBQUM7UUFFUSx5QkFBb0IsR0FBRztZQUNoQyxJQUFJLEVBQUUsUUFBUTtZQUNkLFVBQVUsRUFBRSxPQUFPO1lBQ25CLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTztZQUNyQixNQUFNLEVBQUUsR0FBRyxFQUFFO2dCQUNaLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO2dCQUN4QixJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztnQkFDeEIsSUFBSSxDQUFDLHVCQUF1QixFQUFFLENBQUM7WUFDaEMsQ0FBQztZQUNELE9BQU8sRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFO2dCQUNqQiw0RkFBNEY7Z0JBQzVGLHVDQUF1QztnQkFDdkMsSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtvQkFDekMsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQztvQkFDeEQsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQztvQkFDbEUsSUFBSSxVQUFVLElBQUksZUFBZSxFQUFFO3dCQUNsQyxNQUFNLFNBQVMsR0FBRyxDQUFDLElBQVksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO3dCQUM1RixJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxlQUFlLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUN0RixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUMsQ0FBQztxQkFDcEQ7aUJBQ0Q7Z0JBQ0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDekIsQ0FBQztZQUNELFdBQVcsRUFBRSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxFQUFFO2dCQUMzQyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1lBQ2hELENBQUM7WUFDRCxTQUFTLEVBQUUsSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUNoQyxTQUFTLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUMvQixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7U0FDakIsQ0FBQztRQUVRLHNCQUFpQixHQUFHLElBQUksQ0FBQztRQWlIbkMsY0FBUyxHQUFjLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUVqQyxvQkFBZSxHQUFHLENBQUMsQ0FBTSxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFrUHhCLHlCQUFvQixHQUFHLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBaFc5RCxDQUFDO0lBL0hMLElBQWEsS0FBSyxDQUFDLENBQW9CO1FBQ3RDLElBQUksQ0FBQyxDQUFDLEVBQUU7WUFDUCxDQUFDLEdBQUcsRUFBRSxDQUFDO1NBQ1A7UUFDRCxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztJQUNqQixDQUFDO0lBRUQsSUFBSSxLQUFLO1FBQ1IsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3BCLENBQUM7SUFnREQsSUFDSSxnQkFBZ0IsQ0FBQyxPQUF5QjtRQUM3QyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzdFLENBQUM7SUFDRCxJQUFJLGdCQUFnQjtRQUNuQixNQUFNLE9BQU8sR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sRUFBRSxnQ0FBZ0MsQ0FBQyxDQUFDO1FBQ3BFLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNmLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksSUFBSSxDQUFDLEVBQUUsYUFBYSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDakY7UUFDRCxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxJQUFJLENBQUMsb0JBQW9CLEVBQUU7WUFDM0UsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsUUFBUTtZQUNyQyxPQUFPO1lBQ1AsVUFBVSxFQUFFLElBQUksQ0FBQyxVQUFVO1lBQzNCLE1BQU0sRUFBRSxTQUFTLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksU0FBUyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO1NBQ3JGLENBQUMsQ0FBQztJQUNKLENBQUM7SUF5REQsUUFBUTtRQUNQLDZFQUE2RTtRQUM3RSw2Q0FBNkM7UUFDN0MsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxLQUFLLElBQUksRUFBRTtZQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUNsRCxJQUFJLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQztnQkFDdkIsSUFBSSxDQUFDLHNCQUFzQixFQUFFLENBQUM7WUFDL0IsQ0FBQyxDQUFDLENBQUM7U0FDSDtJQUNGLENBQUM7SUFFRCxXQUFXLENBQUMsT0FBc0I7UUFDakMsdUVBQXVFO1FBQ3ZFLE1BQU0sbUJBQW1CLEdBQUc7WUFDM0IsT0FBTztZQUNQLFlBQVk7WUFDWixVQUFVO1lBQ1YsSUFBSTtZQUNKLE9BQU87WUFDUCxTQUFTO1lBQ1Qsa0JBQWtCO1NBQ2xCLENBQUM7UUFDRixNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3hDLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO1lBQzlELElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDM0M7SUFDRixDQUFDO0lBRUQsZUFBZTtRQUNkLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDNUQsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ2YsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUNqRTtRQUNELFVBQVUsQ0FBQyxHQUFHLEVBQUU7WUFDZixJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUMxQixDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsdUZBQXVGO0lBQ3ZGLHVGQUF1RjtJQUN2RixzRkFBc0Y7SUFDdEYsa0JBQWtCO1FBQ2pCLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsRUFBRTtZQUM5Qiw4REFBOEQ7WUFDOUQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLFNBQVMsQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUMvRSw0RUFBNEU7WUFDNUUsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUUsRUFBRTtnQkFDN0IsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7b0JBQzFCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2lCQUMvQjthQUNEO1NBQ0Q7SUFDRixDQUFDO0lBR0QsT0FBTztRQUNOLHVFQUF1RTtRQUN2RSxvRUFBb0U7UUFDcEUsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ2YsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxhQUFhLEtBQUssUUFBUSxDQUFDLGFBQWEsSUFBSSxJQUFJLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUM5RyxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUN4RSxJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLFlBQVksRUFBRSxLQUFLLENBQUMsQ0FBQzthQUN4RDtpQkFBTSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLGFBQWEsS0FBSyxRQUFRLENBQUMsYUFBYSxJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQ2hILE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQ3hFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsWUFBWSxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQ3hEO1NBQ0Q7SUFDRixDQUFDO0lBR0QsVUFBVTtRQUNULElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUNsQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsVUFBVSxDQUFDLEtBQXdCO1FBQ2xDLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLFVBQVUsQ0FBQyxHQUFHLEVBQUU7WUFDZixJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUU7Z0JBQzlELElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQy9CO1FBQ0YsQ0FBQyxDQUFDLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsZ0JBQWdCLENBQUMsVUFBbUI7UUFDbkMsSUFBSSxDQUFDLFFBQVEsR0FBRyxVQUFVLENBQUM7SUFDNUIsQ0FBQztJQUVELGdCQUFnQixDQUFDLEVBQU87UUFDdkIsSUFBSSxDQUFDLGVBQWUsR0FBRyxFQUFFLENBQUM7SUFDM0IsQ0FBQztJQUVELGlCQUFpQixDQUFDLEVBQU87UUFDeEIsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7SUFDckIsQ0FBQztJQU1EOztPQUVHO0lBQ0gsV0FBVztRQUNWLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsRUFBRTtZQUFFLE9BQU87U0FBRTtRQUMxQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDbEMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsYUFBYSxDQUFDLEtBQWE7UUFDMUIsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUUsRUFBRTtZQUM3QixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDdEUsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO2dCQUNmLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDcEU7aUJBQU07Z0JBQ04sSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7YUFDM0I7WUFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUMsQ0FBQztTQUNwRDtJQUNGLENBQUM7SUFFRDs7T0FFRztJQUNILGtCQUFrQixDQUFDLEtBQWE7UUFDL0IsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUUsSUFBSSxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxFQUFFO1lBQzlELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUN0RSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ3BFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDO1NBQ3BEO0lBQ0YsQ0FBQztJQUVEOztPQUVHO0lBQ0gsWUFBWSxDQUFDLGVBQWdDO1FBQzVDLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNmLGVBQWUsQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBRTVDLHFGQUFxRjtZQUNyRixvRkFBb0Y7WUFDcEYscUVBQXFFO1lBQ3JFLElBQUksZUFBZSxLQUFLLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRTtnQkFDOUUsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFFeEUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO2dCQUMzRixJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLFlBQVksRUFBRSxLQUFLLENBQUMsQ0FBQzthQUN4RDtTQUNEO2FBQU07WUFDTix3RkFBd0Y7WUFDeEYsdUZBQXVGO1lBQ3ZGLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUM5QjtJQUNGLENBQUM7SUFFUyx1QkFBdUI7UUFDaEMsTUFBTSxpQkFBaUIsR0FBRyxRQUFRLENBQUMsZ0JBQWdCLENBQUMscUJBQXFCLENBQUMsQ0FBQztRQUMzRSxLQUFLLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ2hELFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7WUFDakUsUUFBUSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUMvRCxDQUFDLENBQUMsQ0FBQztJQUNKLENBQUM7SUFFRDs7T0FFRztJQUNPLGlCQUFpQjtRQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLEVBQUU7WUFDOUIsT0FBTztTQUNQO1FBRUQsNEVBQTRFO1FBQzVFLHVDQUF1QztRQUN2QyxNQUFNLHdCQUF3QixHQUFHLENBQUMsT0FBeUIsRUFBRSxFQUFFO1lBQzlELE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxLQUFvQixFQUFFLEVBQUU7Z0JBQzVELElBQUksS0FBSyxDQUFDLEdBQUcsS0FBSyxRQUFRLEVBQUU7b0JBQzNCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLEVBQUUsQ0FBQztpQkFDL0I7Z0JBQ0QsSUFBSSxLQUFLLENBQUMsR0FBRyxLQUFLLFdBQVcsRUFBRTtvQkFDOUIsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUU7d0JBQ25DLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsQ0FBQztxQkFDOUI7b0JBRUQsTUFBTSxpQkFBaUIsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsaUJBQWlCLENBQUM7b0JBQ25FLE1BQU0sVUFBVSxHQUFHLGlCQUFpQixJQUFJLGlCQUFpQixDQUFDLGFBQWEsQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO29CQUVwRyxJQUFJLFVBQVUsRUFBRTt3QkFDZixVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7d0JBRW5CLGtGQUFrRjt3QkFDbEYsZ0ZBQWdGO3dCQUNoRixrRkFBa0Y7d0JBQ2xGLDBFQUEwRTt3QkFDMUUsSUFBSSxRQUFRLENBQUMsYUFBYSxLQUFLLFVBQVUsSUFBSSxJQUFJLENBQUMsaUJBQWlCLENBQUMsZ0JBQWdCLEVBQUU7NEJBQ3JGLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQzt5QkFDaEQ7cUJBQ0Q7aUJBQ0Q7WUFDRixDQUFDLENBQUMsQ0FBQztRQUNKLENBQUMsQ0FBQztRQUVGLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRTtZQUNuQyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQztTQUN6RDtRQUVELElBQUksSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRTtZQUM3Qyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQztTQUM5RDtJQUNGLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDTyxzQkFBc0IsQ0FBQyxRQUF1QjtRQUN2RCxJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxFQUFFO1lBQzdCLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUM7WUFDakQsSUFBSSxRQUFRLElBQUksSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsUUFBUSxDQUFDLGFBQWEsQ0FBQyxFQUFFO2dCQUN2RixLQUFLLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQzthQUM5QjtZQUNELHFEQUFxRDtZQUNyRCw4REFBOEQ7WUFDOUQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLFNBQVMsQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUMvRSxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzFCO0lBQ0YsQ0FBQztJQUVEOztPQUVHO0lBQ08sZ0JBQWdCO1FBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQUUsT0FBTztTQUFFO1FBQ2pDLHdHQUF3RztRQUN4RyxNQUFNLGlCQUFpQixHQUFHLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1FBQzNFLE1BQU0sY0FBYyxHQUFHLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBQ3JFLE1BQU0saUJBQWlCLEdBQUcsUUFBUSxDQUFDLGdCQUFnQixDQUFDLHFCQUFxQixDQUFDLENBQUM7UUFDM0UsTUFBTSxnQkFBZ0IsR0FBRyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUN6RSxNQUFNLGFBQWEsR0FBRyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUNuRSxNQUFNLFlBQVksR0FBRyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUVqRSxtQ0FBbUM7UUFDbkMsTUFBTSxtQkFBbUIsR0FBRyxDQUFDLFNBQWlCLEVBQUUsV0FBZ0MsRUFBRSxFQUFFO1lBQ25GLEtBQUssQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUN6QyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEVBQUU7b0JBQzNDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2lCQUNqQztZQUNGLENBQUMsQ0FBQyxDQUFDO1FBQ0osQ0FBQyxDQUFDO1FBRUYsNkRBQTZEO1FBQzdELG1CQUFtQixDQUFDLDRCQUE0QixFQUFFLGlCQUFpQixDQUFDLENBQUM7UUFDckUsbUJBQW1CLENBQUMseUJBQXlCLEVBQUUsY0FBYyxDQUFDLENBQUM7UUFDL0QsbUJBQW1CLENBQUMsNEJBQTRCLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztRQUNyRSxtQkFBbUIsQ0FBQyx3QkFBd0IsRUFBRSxhQUFhLENBQUMsQ0FBQztRQUU3RCwwQ0FBMEM7UUFDMUMsS0FBSyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUM5QyxPQUFPLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQztZQUMxRCxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO1FBQ3BELENBQUMsQ0FBQyxDQUFDO1FBRUgsNkVBQTZFO1FBQzdFLEtBQUssQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQzFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLHVCQUF1QixDQUFDLENBQUM7WUFDL0MsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUU7Z0JBQ2hCLE9BQU87YUFDUDtZQUNELElBQUksT0FBTyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUNqRSxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUNuQztpQkFBTSxJQUFJLE9BQU8sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtnQkFDMUUsT0FBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7YUFDdEM7UUFDRixDQUFDLENBQUMsQ0FBQztJQUNKLENBQUM7SUFFUyxnQkFBZ0I7UUFDekIsTUFBTSxpQkFBaUIsR0FBRyxRQUFRLENBQUMsZ0JBQWdCLENBQUMscUJBQXFCLENBQUMsQ0FBQztRQUMzRSxLQUFLLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ2hELFFBQVEsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQ3hDLFFBQVEsQ0FBQyxZQUFZLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNyRCxDQUFDLENBQUMsQ0FBQztJQUNKLENBQUM7SUFFRDs7O09BR0c7SUFDTyxhQUFhLENBQUMsS0FBd0I7UUFDL0MsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUUsRUFBRTtZQUM3QixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsSUFBSSxJQUFJLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUNyRixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsSUFBSSxJQUFJLENBQUMsRUFBRSxhQUFhLENBQUMsQ0FBQztZQUV6RixzRkFBc0Y7WUFDdEYscUZBQXFGO1lBQ3JGLHVGQUF1RjtZQUN2RixJQUFJLHdCQUF3QixHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxnQkFBZ0IsS0FBSyxRQUFRLENBQUMsYUFBYSxDQUFDO1lBRWxHLCtCQUErQjtZQUMvQixJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBRXRDLElBQUksd0JBQXdCLEVBQUU7Z0JBQzdCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQzthQUNoRDtZQUVELHNGQUFzRjtZQUN0RixJQUFJLFVBQVUsR0FBRyxFQUFFLENBQUM7WUFDcEIsd0NBQXdDO1lBQ3hDLElBQUksT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxLQUFLLFFBQVEsRUFBRTtnQkFDaEUsVUFBVSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQ3hHLFVBQVUsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQzdFLHlFQUF5RTthQUN4RTtpQkFBTSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUNyRCxVQUFVLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQzthQUN6RztZQUVELElBQUksVUFBVSxFQUFFO2dCQUNmLHNGQUFzRjtnQkFDdEYsSUFBSSxTQUFTLEdBQUcsRUFBRSxDQUFDO2dCQUNuQix3Q0FBd0M7Z0JBQ3hDLElBQUksT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxLQUFLLFFBQVEsRUFBRTtvQkFDaEUsU0FBUyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7b0JBQ2xILFNBQVMsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7b0JBQzNFLHlFQUF5RTtpQkFDeEU7cUJBQU0sSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRTtvQkFDckQsU0FBUyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7aUJBQ3hHO2dCQUNELFVBQVUsQ0FBQyxHQUFHLEVBQUU7b0JBQ2YsbUJBQW1CO29CQUNuQixVQUFVLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQztvQkFDN0IsV0FBVyxDQUFDLEtBQUssR0FBRyxVQUFVLENBQUM7Z0JBQ2hDLENBQUMsQ0FBQyxDQUFDO2FBQ0g7U0FDRDtJQUNGLENBQUM7SUFJUyxRQUFRLENBQUMsYUFBZ0M7UUFDbEQsZ0dBQWdHO1FBQ2hHLGlGQUFpRjtRQUNqRixzRUFBc0U7UUFDdEUsSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDMUQsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUV4RSwwRkFBMEY7WUFDMUYscUZBQXFGO1lBQ3JGLDJGQUEyRjtZQUMzRixJQUFJLHdCQUF3QixHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxnQkFBZ0IsS0FBSyxRQUFRLENBQUMsYUFBYSxDQUFDO1lBRWxHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsWUFBWSxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBRXhELElBQUksd0JBQXdCLEVBQUU7Z0JBQzdCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQzthQUNoRDtTQUVEO1FBQ0QsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRVMsa0JBQWtCLENBQUMsWUFBWSxFQUFFLGFBQWE7UUFDdkQsT0FBTyxZQUFZLENBQUMsQ0FBQyxDQUFDLEtBQUssYUFBYSxDQUFDLENBQUMsQ0FBQyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsS0FBSyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckYsQ0FBQztJQUVEOztPQUVHO0lBQ08saUJBQWlCO1FBQzFCLHdIQUF3SDtRQUN4SCxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUM7SUFDckUsQ0FBQztJQUVEOztPQUVHO0lBQ08sY0FBYztRQUN2QixPQUFPOzs7O1VBSUMsQ0FBQztJQUNWLENBQUM7SUFFRDs7T0FFRztJQUNPLGFBQWE7UUFDdEIsT0FBTzs7OztVQUlDLENBQUM7SUFDVixDQUFDOztBQWprQmMsMEJBQWUsR0FBRyxDQUFFLENBQUE7dUdBTnZCLFVBQVU7MkZBQVYsVUFBVSx5ekJBVFg7UUFDVjtZQUNDLE9BQU8sRUFBRSxpQkFBaUI7WUFDMUIsV0FBVyxFQUFFLFVBQVU7WUFDdkIsS0FBSyxFQUFFLElBQUk7U0FDWDtLQUNELHdQQTlEUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXVEVDsyRkFVVyxVQUFVO2tCQW5FdEIsU0FBUzttQkFBQztvQkFDVixRQUFRLEVBQUUsa0NBQWtDO29CQUM1QyxRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUF1RFQ7b0JBQ0QsU0FBUyxFQUFFO3dCQUNWOzRCQUNDLE9BQU8sRUFBRSxpQkFBaUI7NEJBQzFCLFdBQVcsWUFBWTs0QkFDdkIsS0FBSyxFQUFFLElBQUk7eUJBQ1g7cUJBQ0Q7b0JBQ0QsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7aUJBQ3JDO29IQVlTLEtBQUs7c0JBQWIsS0FBSztnQkFPRyxVQUFVO3NCQUFsQixLQUFLO2dCQVFHLFFBQVE7c0JBQWhCLEtBQUs7Z0JBRUcsS0FBSztzQkFBYixLQUFLO2dCQUNHLFVBQVU7c0JBQWxCLEtBQUs7Z0JBQ0csZUFBZTtzQkFBdkIsS0FBSztnQkFDRyxVQUFVO3NCQUFsQixLQUFLO2dCQUVHLFdBQVc7c0JBQW5CLEtBQUs7Z0JBS0csU0FBUztzQkFBakIsS0FBSztnQkFLRyxZQUFZO3NCQUFwQixLQUFLO2dCQUVHLEVBQUU7c0JBQVYsS0FBSztnQkFFTyxLQUFLO3NCQUFqQixLQUFLO2dCQWVHLEtBQUs7c0JBQWIsS0FBSztnQkFFRyxRQUFRO3NCQUFoQixLQUFLO2dCQUlHLE9BQU87c0JBQWYsS0FBSztnQkFJRyxXQUFXO3NCQUFuQixLQUFLO2dCQUlHLElBQUk7c0JBQVosS0FBSztnQkFJRyxRQUFRO3NCQUFoQixLQUFLO2dCQUVHLElBQUk7c0JBQVosS0FBSztnQkFJRyxZQUFZO3NCQUFwQixLQUFLO2dCQUlHLGdCQUFnQjtzQkFBeEIsS0FBSztnQkFJRyxTQUFTO3NCQUFqQixLQUFLO2dCQUlHLGFBQWE7c0JBQXJCLEtBQUs7Z0JBRUcsUUFBUTtzQkFBaEIsS0FBSztnQkFFRyxPQUFPO3NCQUFmLEtBQUs7Z0JBR0YsZ0JBQWdCO3NCQURuQixLQUFLO2dCQWlCZ0MsS0FBSztzQkFBMUMsU0FBUzt1QkFBQyxPQUFPLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO2dCQUNYLFVBQVU7c0JBQWxDLFNBQVM7dUJBQUMsWUFBWTtnQkFFYixXQUFXO3NCQUFwQixNQUFNO2dCQU1HLE9BQU87c0JBQWhCLE1BQU07Z0JBcUdQLE9BQU87c0JBRE4sWUFBWTt1QkFBQyxTQUFTO2dCQWdCdkIsVUFBVTtzQkFEVCxZQUFZO3VCQUFDLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRDb21wb25lbnQsXG5cdElucHV0LFxuXHRPdXRwdXQsXG5cdEV2ZW50RW1pdHRlcixcblx0Vmlld0VuY2Fwc3VsYXRpb24sXG5cdEVsZW1lbnRSZWYsXG5cdE9uRGVzdHJveSxcblx0SG9zdExpc3RlbmVyLFxuXHRUZW1wbGF0ZVJlZixcblx0T25DaGFuZ2VzLFxuXHRTaW1wbGVDaGFuZ2VzLFxuXHRBZnRlclZpZXdDaGVja2VkLFxuXHRBZnRlclZpZXdJbml0LFxuXHRWaWV3Q2hpbGQsXG5cdE9uSW5pdCxcblx0U2ltcGxlQ2hhbmdlXG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgcmFuZ2VQbHVnaW4gZnJvbSBcImZsYXRwaWNrci9kaXN0L3BsdWdpbnMvcmFuZ2VQbHVnaW5cIjtcbmltcG9ydCBmbGF0cGlja3IgZnJvbSBcImZsYXRwaWNrclwiO1xuaW1wb3J0IHsgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tIFwiQGFuZ3VsYXIvZm9ybXNcIjtcbmltcG9ydCB7IGNhcmJvbkZsYXRwaWNrck1vbnRoU2VsZWN0UGx1Z2luIH0gZnJvbSBcIi4vY2FyYm9uLWZsYXRwaWNrci1tb250aC1zZWxlY3RcIjtcbmltcG9ydCAqIGFzIGxhbmd1YWdlcyBmcm9tIFwiZmxhdHBpY2tyL2Rpc3QvbDEwbi9pbmRleFwiO1xuaW1wb3J0IHsgT3B0aW9ucyB9IGZyb20gXCJmbGF0cGlja3IvZGlzdC90eXBlcy9vcHRpb25zXCI7XG5pbXBvcnQgeyBEYXRlUGlja2VySW5wdXQgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9kYXRlcGlja2VyLWlucHV0XCI7XG5pbXBvcnQgeyBJMThuIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvaTE4blwiO1xuXG4vKipcbiAqIER1ZSB0byB0eXBlIGVycm9yLCB3ZSBoYXZlIHRvIHVzZSBzcXVhcmUgYnJhY2tldHMgcHJvcGVydHkgYWNjZXNzb3JcbiAqIFRoZXJlIGlzIGEgd2VicGFjayBpc3N1ZSB3aGVuIGF0dGVtcHRpbmcgdG8gYWNjZXNzIGV4cG9ydGVkIGxhbmd1YWdlcyBmcm9tIGZsYXRwaWNrciBsMTBuIEFuZ3VsYXIgMTQrIGFwcHNcbiAqIGxhbmd1YWdlcy5kZWZhdWx0W2xvY2FsZV0gZmFpbHMgaW4gYXBwIGNvbnN1bWluZyBDQ0EgbGlicmFyeSBidXQgcGFzc2VzIGluIHRlc3RcbiAqIGxhbmd1YWdlcy5kZWZhdWx0LmRlZmF1bHRbbG9jYWxlXSBmYWlscyBpbiB0ZXN0IGJ1dCB3b3JrcyBpbiBhcHAgY29uc3VtaW5nIENDQSBsaWJyYXJ5LlxuICpcbiAqIFRvIHBsZWFzZSBib3RoIHNjZW5hcmlvcywgd2UgYXJlIGFkZGluZyBhIGNvbmRpdGlvbiB0byBwcmV2ZW50IHRlc3RzIGZyb20gZmFpbGluZ1xuICovXG5pZiAobGFuZ3VhZ2VzLmRlZmF1bHQ/LmRlZmF1bHRbXCJlblwiXT8ud2Vla2RheXMpIHtcblx0KGxhbmd1YWdlcy5kZWZhdWx0LmRlZmF1bHRbXCJlblwiXS53ZWVrZGF5cy5zaG9ydGhhbmQgYXMgc3RyaW5nW10pID0gbGFuZ3VhZ2VzLmRlZmF1bHQuZGVmYXVsdFtcImVuXCJdLndlZWtkYXlzLmxvbmdoYW5kLm1hcChkYXkgPT4ge1xuXHRcdGlmIChkYXkgPT09IFwiVGh1cnNkYXlcIikge1xuXHRcdFx0cmV0dXJuIFwiVGhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIGRheS5jaGFyQXQoMCk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEdldCBzdGFydGVkIHdpdGggaW1wb3J0aW5nIHRoZSBtb2R1bGU6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgRGF0ZVBpY2tlck1vZHVsZSB9IGZyb20gJ2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXInO1xuICogYGBgXG4gKlxuICogW1NlZSBkZW1vXSguLi8uLi8/cGF0aD0vc3RvcnkvY29tcG9uZW50cy1kYXRlLXBpY2tlci0tc2luZ2xlKVxuICovXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6IFwiY2RzLWRhdGUtcGlja2VyLCBpYm0tZGF0ZS1waWNrZXJcIixcblx0dGVtcGxhdGU6IGBcblx0PGRpdiBjbGFzcz1cImNkcy0tZm9ybS1pdGVtXCI+XG5cdFx0PGRpdlxuXHRcdFx0Y2xhc3M9XCJjZHMtLWRhdGUtcGlja2VyXCJcblx0XHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdFx0J2Nkcy0tZGF0ZS1waWNrZXItLXJhbmdlJyA6IHJhbmdlLFxuXHRcdFx0XHQnY2RzLS1kYXRlLXBpY2tlci0tc2luZ2xlJyA6ICFyYW5nZSxcblx0XHRcdFx0J2Nkcy0tZGF0ZS1waWNrZXItLWxpZ2h0JyA6IHRoZW1lID09PSAnbGlnaHQnLFxuXHRcdFx0XHQnY2RzLS1za2VsZXRvbicgOiBza2VsZXRvblxuXHRcdFx0fVwiPlxuXHRcdFx0PGRpdiBjbGFzcz1cImNkcy0tZGF0ZS1waWNrZXItY29udGFpbmVyXCI+XG5cdFx0XHRcdDxjZHMtZGF0ZS1waWNrZXItaW5wdXRcblx0XHRcdFx0XHQjaW5wdXRcblx0XHRcdFx0XHRbbGFiZWxdPVwibGFiZWxcIlxuXHRcdFx0XHRcdFtwbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG5cdFx0XHRcdFx0W3BhdHRlcm5dPVwiaW5wdXRQYXR0ZXJuXCJcblx0XHRcdFx0XHRbaWRdPVwiaWQgKyAnLWlucHV0J1wiXG5cdFx0XHRcdFx0W3NpemVdPVwic2l6ZVwiXG5cdFx0XHRcdFx0W3R5cGVdPVwiKHJhbmdlID8gJ3JhbmdlJyA6ICdzaW5nbGUnKVwiXG5cdFx0XHRcdFx0W2hhc0ljb25dPVwiKHJhbmdlID8gZmFsc2UgOiB0cnVlKVwiXG5cdFx0XHRcdFx0W2Rpc2FibGVkXT1cImRpc2FibGVkXCJcblx0XHRcdFx0XHRbaW52YWxpZF09XCJpbnZhbGlkXCJcblx0XHRcdFx0XHRbaW52YWxpZFRleHRdPVwiaW52YWxpZFRleHRcIlxuXHRcdFx0XHRcdFt3YXJuXT1cIndhcm5cIlxuXHRcdFx0XHRcdFt3YXJuVGV4dF09XCJ3YXJuVGV4dFwiXG5cdFx0XHRcdFx0W3NrZWxldG9uXT1cInNrZWxldG9uXCJcblx0XHRcdFx0XHRbaGVscGVyVGV4dF09XCJoZWxwZXJUZXh0XCJcblx0XHRcdFx0XHQodmFsdWVDaGFuZ2UpPVwib25WYWx1ZUNoYW5nZSgkZXZlbnQpXCJcblx0XHRcdFx0XHQoY2xpY2spPVwib3BlbkNhbGVuZGFyKGlucHV0KVwiPlxuXHRcdFx0XHQ8L2Nkcy1kYXRlLXBpY2tlci1pbnB1dD5cblx0XHRcdDwvZGl2PlxuXG5cdFx0XHQ8ZGl2ICpuZ0lmPVwicmFuZ2VcIiBjbGFzcz1cImNkcy0tZGF0ZS1waWNrZXItY29udGFpbmVyXCI+XG5cdFx0XHRcdDxjZHMtZGF0ZS1waWNrZXItaW5wdXRcblx0XHRcdFx0XHQjcmFuZ2VJbnB1dFxuXHRcdFx0XHRcdFtsYWJlbF09XCJyYW5nZUxhYmVsXCJcblx0XHRcdFx0XHRbcGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIlxuXHRcdFx0XHRcdFtwYXR0ZXJuXT1cImlucHV0UGF0dGVyblwiXG5cdFx0XHRcdFx0W2lkXT1cImlkICsgJy1yYW5nZUlucHV0J1wiXG5cdFx0XHRcdFx0W3NpemVdPVwic2l6ZVwiXG5cdFx0XHRcdFx0W3R5cGVdPVwiKHJhbmdlID8gJ3JhbmdlJyA6ICdzaW5nbGUnKVwiXG5cdFx0XHRcdFx0W2hhc0ljb25dPVwiKHJhbmdlID8gdHJ1ZSA6IG51bGwpXCJcblx0XHRcdFx0XHRbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuXHRcdFx0XHRcdFtpbnZhbGlkXT1cInJhbmdlSW52YWxpZFwiXG5cdFx0XHRcdFx0W2ludmFsaWRUZXh0XT1cInJhbmdlSW52YWxpZFRleHRcIlxuXHRcdFx0XHRcdFt3YXJuXT1cInJhbmdlV2FyblwiXG5cdFx0XHRcdFx0W3dhcm5UZXh0XT1cInJhbmdlV2FyblRleHRcIlxuXHRcdFx0XHRcdFtza2VsZXRvbl09XCJza2VsZXRvblwiXG5cdFx0XHRcdFx0W2hlbHBlclRleHRdPVwicmFuZ2VIZWxwZXJUZXh0XCJcblx0XHRcdFx0XHQodmFsdWVDaGFuZ2UpPVwib25SYW5nZVZhbHVlQ2hhbmdlKCRldmVudClcIlxuXHRcdFx0XHRcdChjbGljayk9XCJvcGVuQ2FsZW5kYXIocmFuZ2VJbnB1dClcIj5cblx0XHRcdFx0PC9jZHMtZGF0ZS1waWNrZXItaW5wdXQ+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG5cdGAsXG5cdHByb3ZpZGVyczogW1xuXHRcdHtcblx0XHRcdHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuXHRcdFx0dXNlRXhpc3Rpbmc6IERhdGVQaWNrZXIsXG5cdFx0XHRtdWx0aTogdHJ1ZVxuXHRcdH1cblx0XSxcblx0ZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBEYXRlUGlja2VyIGltcGxlbWVudHNcblx0T25Jbml0LFxuXHRPbkRlc3Ryb3ksXG5cdE9uQ2hhbmdlcyxcblx0QWZ0ZXJWaWV3Q2hlY2tlZCxcblx0QWZ0ZXJWaWV3SW5pdCB7XG5cdHByaXZhdGUgc3RhdGljIGRhdGVQaWNrZXJDb3VudCA9IDA7XG5cblx0LyoqXG5cdCAqIFNlbGVjdCBjYWxlbmRhciByYW5nZSBtb2RlXG5cdCAqL1xuXHRASW5wdXQoKSByYW5nZSA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBGb3JtYXQgb2YgZGF0ZVxuXHQgKlxuXHQgKiBGb3IgcmVmZXJlbmNlOiBodHRwczovL2ZsYXRwaWNrci5qcy5vcmcvZm9ybWF0dGluZy9cblx0ICovXG5cdEBJbnB1dCgpIGRhdGVGb3JtYXQgPSBcIm0vZC9ZXCI7XG5cblx0LyoqXG5cdCAqIExhbmd1YWdlIG9mIHRoZSBmbGF0cGlja3IgY2FsZW5kYXIuXG5cdCAqXG5cdCAqIEZvciByZWZlcmVuY2Ugb2YgdGhlIHBvc3NpYmxlIGxvY2FsZXM6XG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mbGF0cGlja3IvZmxhdHBpY2tyL2Jsb2IvbWFzdGVyL3NyYy9sMTBuL2luZGV4LnRzXG5cdCAqL1xuXHRASW5wdXQoKSBsYW5ndWFnZSA9IFwiZW5cIjtcblxuXHRASW5wdXQoKSBsYWJlbDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55Pjtcblx0QElucHV0KCkgaGVscGVyVGV4dDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55Pjtcblx0QElucHV0KCkgcmFuZ2VIZWxwZXJUZXh0OiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+O1xuXHRASW5wdXQoKSByYW5nZUxhYmVsOiBzdHJpbmc7XG5cblx0QElucHV0KCkgcGxhY2Vob2xkZXIgPSBcIm1tL2RkL3l5eXlcIjtcblxuXHQvKipcblx0ICogQXJpYSBsYWJlbCBhZGRlZCB0byBkYXRlcGlja2VyJ3MgY2FsZW5kYXIgY29udGFpbmVyLlxuXHQgKi9cblx0QElucHV0KCkgYXJpYUxhYmVsID0gXCJjYWxlbmRhciBjb250YWluZXJcIjtcblxuXHQvKipcblx0ICogVGhlIHBhdHRlcm4gZm9yIHRoZSB1bmRlcmx5aW5nIGlucHV0IGVsZW1lbnRcblx0ICovXG5cdEBJbnB1dCgpIGlucHV0UGF0dGVybiA9IFwiXlxcXFxkezEsMn0vXFxcXGR7MSwyfS9cXFxcZHs0fSRcIjtcblxuXHRASW5wdXQoKSBpZCA9IGBkYXRlcGlja2VyLSR7RGF0ZVBpY2tlci5kYXRlUGlja2VyQ291bnQrK31gO1xuXG5cdEBJbnB1dCgpIHNldCB2YWx1ZSh2OiAoRGF0ZSB8IHN0cmluZylbXSkge1xuXHRcdGlmICghdikge1xuXHRcdFx0diA9IFtdO1xuXHRcdH1cblx0XHR0aGlzLl92YWx1ZSA9IHY7XG5cdH1cblxuXHRnZXQgdmFsdWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHY1IC0gVXNlIGBjZHNMYXllcmAgZGlyZWN0aXZlIGluc3RlYWRcblx0ICogU2V0IHRvIGBcImxpZ2h0XCJgIHRvIGFwcGx5IHRoZSBsaWdodCBzdHlsZVxuXHQgKi9cblx0QElucHV0KCkgdGhlbWU6IFwibGlnaHRcIiB8IFwiZGFya1wiID0gXCJkYXJrXCI7XG5cblx0QElucHV0KCkgZGlzYWJsZWQgPSBmYWxzZTtcblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgdG8gZGlzcGxheSB0aGUgaW52YWxpZCBzdGF0ZS5cblx0ICovXG5cdEBJbnB1dCgpIGludmFsaWQgPSBmYWxzZTtcblx0LyoqXG5cdCAqIFZhbHVlIGRpc3BsYXllZCBpZiBkYXRlcGlja2VyIGlzIGluIGFuIGludmFsaWQgc3RhdGUuXG5cdCAqL1xuXHRASW5wdXQoKSBpbnZhbGlkVGV4dDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55Pjtcblx0LyoqXG5cdCAgKiBTZXQgdG8gYHRydWVgIHRvIHNob3cgYSB3YXJuaW5nIChjb250ZW50cyBzZXQgYnkgd2FybmluZ1RleHQpXG5cdCAgKi9cblx0QElucHV0KCkgd2FybiA9IGZhbHNlO1xuXHQvKipcblx0ICogU2V0cyB0aGUgd2FybmluZyB0ZXh0XG5cdCAqL1xuXHRASW5wdXQoKSB3YXJuVGV4dDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55PjtcblxuXHRASW5wdXQoKSBzaXplOiBcInNtXCIgfCBcIm1kXCIgfCBcImxnXCIgPSBcIm1kXCI7XG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIHRvIGRpc3BsYXkgdGhlIGludmFsaWQgc3RhdGUgZm9yIHRoZSBzZWNvbmQgZGF0ZXBpY2tlciBpbnB1dC5cblx0ICovXG5cdEBJbnB1dCgpIHJhbmdlSW52YWxpZCA9IGZhbHNlO1xuXHQvKipcblx0ICogVmFsdWUgZGlzcGxheWVkIGlmIHRoZSBzZWNvbmQgZGF0ZXBpY2tlciBpbnB1dCBpcyBpbiBhbiBpbnZhbGlkIHN0YXRlLlxuXHQgKi9cblx0QElucHV0KCkgcmFuZ2VJbnZhbGlkVGV4dDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55Pjtcblx0LyoqXG5cdCAgKiBTZXQgdG8gYHRydWVgIHRvIHNob3cgYSB3YXJuaW5nIGluIHRoZSBzZWNvbmQgZGF0ZXBpY2tlciBpbnB1dCAoY29udGVudHMgc2V0IGJ5IHJhbmdlV2FybmluZ1RleHQpXG5cdCAgKi9cblx0QElucHV0KCkgcmFuZ2VXYXJuID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB3YXJuaW5nIHRleHQgZm9yIHRoZSBzZWNvbmQgZGF0ZXBpY2tlciBpbnB1dFxuXHQgKi9cblx0QElucHV0KCkgcmFuZ2VXYXJuVGV4dDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55PjtcblxuXHRASW5wdXQoKSBza2VsZXRvbiA9IGZhbHNlO1xuXG5cdEBJbnB1dCgpIHBsdWdpbnMgPSBbXTtcblxuXHRASW5wdXQoKVxuXHRzZXQgZmxhdHBpY2tyT3B0aW9ucyhvcHRpb25zOiBQYXJ0aWFsPE9wdGlvbnM+KSB7XG5cdFx0dGhpcy5fZmxhdHBpY2tyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2ZsYXRwaWNrck9wdGlvbnMsIG9wdGlvbnMpO1xuXHR9XG5cdGdldCBmbGF0cGlja3JPcHRpb25zKCk6IFBhcnRpYWw8T3B0aW9ucz4ge1xuXHRcdGNvbnN0IHBsdWdpbnMgPSBbLi4udGhpcy5wbHVnaW5zLCBjYXJib25GbGF0cGlja3JNb250aFNlbGVjdFBsdWdpbl07XG5cdFx0aWYgKHRoaXMucmFuZ2UpIHtcblx0XHRcdHBsdWdpbnMucHVzaChyYW5nZVBsdWdpbih7IGlucHV0OiBgIyR7dGhpcy5pZH0tcmFuZ2VJbnB1dGAsIHBvc2l0aW9uOiBcImxlZnRcIiB9KSk7XG5cdFx0fVxuXHRcdHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9mbGF0cGlja3JPcHRpb25zLCB0aGlzLmZsYXRwaWNrckJhc2VPcHRpb25zLCB7XG5cdFx0XHRtb2RlOiB0aGlzLnJhbmdlID8gXCJyYW5nZVwiIDogXCJzaW5nbGVcIixcblx0XHRcdHBsdWdpbnMsXG5cdFx0XHRkYXRlRm9ybWF0OiB0aGlzLmRhdGVGb3JtYXQsXG5cdFx0XHRsb2NhbGU6IGxhbmd1YWdlcy5kZWZhdWx0Py5kZWZhdWx0W3RoaXMubGFuZ3VhZ2VdIHx8IGxhbmd1YWdlcy5kZWZhdWx0W3RoaXMubGFuZ3VhZ2VdXG5cdFx0fSk7XG5cdH1cblxuXHRAVmlld0NoaWxkKFwiaW5wdXRcIiwgeyBzdGF0aWM6IHRydWUgfSkgaW5wdXQ6IERhdGVQaWNrZXJJbnB1dDtcblx0QFZpZXdDaGlsZChcInJhbmdlSW5wdXRcIikgcmFuZ2VJbnB1dDogRGF0ZVBpY2tlcklucHV0O1xuXG5cdEBPdXRwdXQoKSB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblx0LyoqXG5cdCAqIFdlIGFyZSBvdmVycmlkaW5nIG9uQ2xvc2UgZXZlbnQgZXZlbiBpZiB1c2VycyBwYXNzIGl0IHZpYSBmbGF0cGlja3Igb3B0aW9uc1xuXHQgKiBFbWl0cyBhbiBldmVudCB3aGVuIGRhdGUgcGlja2VyIGNsb3Nlc1xuXHQgKi9cblx0QE91dHB1dCgpIG9uQ2xvc2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cdHByb3RlY3RlZCBfdmFsdWUgPSBbXTtcblxuXHRwcm90ZWN0ZWQgX2ZsYXRwaWNrck9wdGlvbnM6IFBhcnRpYWw8T3B0aW9ucz4gPSB7XG5cdFx0YWxsb3dJbnB1dDogdHJ1ZVxuXHR9O1xuXG5cdHByb3RlY3RlZCBmbGF0cGlja3JCYXNlT3B0aW9ucyA9IHtcblx0XHRtb2RlOiBcInNpbmdsZVwiLFxuXHRcdGRhdGVGb3JtYXQ6IFwibS9kL1lcIixcblx0XHRwbHVnaW5zOiB0aGlzLnBsdWdpbnMsXG5cdFx0b25PcGVuOiAoKSA9PiB7XG5cdFx0XHR0aGlzLnVwZGF0ZUNsYXNzTmFtZXMoKTtcblx0XHRcdHRoaXMudXBkYXRlQXR0cmlidXRlcygpO1xuXHRcdFx0dGhpcy51cGRhdGVDYWxlbmRhckxpc3RlbmVycygpO1xuXHRcdH0sXG5cdFx0b25DbG9zZTogKGRhdGUpID0+IHtcblx0XHRcdC8vIFRoaXMgbWFrZXMgc3VyZSB0aGF0IHRoZSBgZmxhdHBpY2tySW5zdGFuY2Ugc2VsZWN0ZWREYXRlc2AgYXJlIGluIHN5bmMgd2l0aCB0aGUgdmFsdWVzIG9mXG5cdFx0XHQvLyB0aGUgaW5wdXRzIHdoZW4gdGhlIGNhbGVuZGFyIGNsb3Nlcy5cblx0XHRcdGlmICh0aGlzLnJhbmdlICYmIHRoaXMuZmxhdHBpY2tySW5zdGFuY2UpIHtcblx0XHRcdFx0Y29uc3QgaW5wdXRWYWx1ZSA9IHRoaXMuaW5wdXQuaW5wdXQubmF0aXZlRWxlbWVudC52YWx1ZTtcblx0XHRcdFx0Y29uc3QgcmFuZ2VJbnB1dFZhbHVlID0gdGhpcy5yYW5nZUlucHV0LmlucHV0Lm5hdGl2ZUVsZW1lbnQudmFsdWU7XG5cdFx0XHRcdGlmIChpbnB1dFZhbHVlIHx8IHJhbmdlSW5wdXRWYWx1ZSkge1xuXHRcdFx0XHRcdGNvbnN0IHBhcnNlRGF0ZSA9IChkYXRlOiBzdHJpbmcpID0+IHRoaXMuZmxhdHBpY2tySW5zdGFuY2UucGFyc2VEYXRlKGRhdGUsIHRoaXMuZGF0ZUZvcm1hdCk7XG5cdFx0XHRcdFx0dGhpcy5zZXREYXRlVmFsdWVzKFtwYXJzZURhdGUoaW5wdXRWYWx1ZSksIHBhcnNlRGF0ZShyYW5nZUlucHV0VmFsdWUgfHwgaW5wdXRWYWx1ZSldKTtcblx0XHRcdFx0XHR0aGlzLmRvU2VsZWN0KHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMub25DbG9zZS5lbWl0KGRhdGUpO1xuXHRcdH0sXG5cdFx0b25EYXlDcmVhdGU6IChfZE9iaiwgX2RTdHIsIF9mcCwgZGF5RWxlbSkgPT4ge1xuXHRcdFx0ZGF5RWxlbS5jbGFzc0xpc3QuYWRkKFwiY2RzLS1kYXRlLXBpY2tlcl9fZGF5XCIpO1xuXHRcdH0sXG5cdFx0bmV4dEFycm93OiB0aGlzLnJpZ2h0QXJyb3dIVE1MKCksXG5cdFx0cHJldkFycm93OiB0aGlzLmxlZnRBcnJvd0hUTUwoKSxcblx0XHR2YWx1ZTogdGhpcy52YWx1ZVxuXHR9O1xuXG5cdHByb3RlY3RlZCBmbGF0cGlja3JJbnN0YW5jZSA9IG51bGw7XG5cblx0Y29uc3RydWN0b3IoXG5cdFx0cHJvdGVjdGVkIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG5cdFx0cHJvdGVjdGVkIGkxOG46IEkxOG5cblx0KSB7IH1cblxuXHRuZ09uSW5pdCgpIHtcblx0XHQvLyBpZiBpMThuIGlzIHNldCB0byBhbnl0aGluZyBvdGhlciB0aGFuIGVuIHdlJ2xsIHdhbnQgdG8gY2hhbmdlIHRoZSBsYW5ndWFnZVxuXHRcdC8vIG90aGVyd2lzZSB3ZSdsbCBqdXN0IHVzZSB0aGUgbG9jYWwgc2V0dGluZ1xuXHRcdGlmICh0aGlzLmkxOG4uZ2V0TG9jYWxlKCkgIT09IFwiZW5cIikge1xuXHRcdFx0dGhpcy5pMThuLmdldExvY2FsZU9ic2VydmFibGUoKS5zdWJzY3JpYmUobG9jYWxlID0+IHtcblx0XHRcdFx0dGhpcy5sYW5ndWFnZSA9IGxvY2FsZTtcblx0XHRcdFx0dGhpcy5yZXNldEZsYXRwaWNrckluc3RhbmNlKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG5cdFx0Ly8gUmVzZXQgdGhlIGZsYXRwaWNrciBpbnN0YW5jZSBvbiBpbnB1dCBjaGFuZ2VzIHRoYXQgYWZmZWN0IGZsYXRwaWNrci5cblx0XHRjb25zdCBmbGF0cGlja3JDaGFuZ2VLZXlzID0gW1xuXHRcdFx0XCJyYW5nZVwiLFxuXHRcdFx0XCJkYXRlRm9ybWF0XCIsXG5cdFx0XHRcImxhbmd1YWdlXCIsXG5cdFx0XHRcImlkXCIsXG5cdFx0XHRcInZhbHVlXCIsXG5cdFx0XHRcInBsdWdpbnNcIixcblx0XHRcdFwiZmxhdHBpY2tyT3B0aW9uc1wiXG5cdFx0XTtcblx0XHRjb25zdCBjaGFuZ2VLZXlzID0gT2JqZWN0LmtleXMoY2hhbmdlcyk7XG5cdFx0aWYgKGNoYW5nZUtleXMuc29tZShrZXkgPT4gZmxhdHBpY2tyQ2hhbmdlS2V5cy5pbmNsdWRlcyhrZXkpKSkge1xuXHRcdFx0dGhpcy5yZXNldEZsYXRwaWNrckluc3RhbmNlKGNoYW5nZXMudmFsdWUpO1xuXHRcdH1cblx0fVxuXG5cdG5nQWZ0ZXJWaWV3SW5pdCgpIHtcblx0XHR0aGlzLmlucHV0LmlucHV0Lm5hdGl2ZUVsZW1lbnQudmFsdWUgPSB0aGlzLl92YWx1ZVswXSA/PyBcIlwiO1xuXHRcdGlmICh0aGlzLnJhbmdlKSB7XG5cdFx0XHR0aGlzLnJhbmdlSW5wdXQuaW5wdXQubmF0aXZlRWxlbWVudC52YWx1ZSA9IHRoaXMuX3ZhbHVlWzFdID8/IFwiXCI7XG5cdFx0fVxuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0dGhpcy5hZGRJbnB1dExpc3RlbmVycygpO1xuXHRcdH0sIDApO1xuXHR9XG5cblx0Ly8gYmVjYXVzZSB0aGUgYWN0dWFsIHZpZXcgbWF5IGJlIGRlbGF5ZWQgaW4gbG9hZGluZyAodGhpbmsgcHJvamVjdGlvbiBpbnRvIGEgdGFiIHBhbmUpXG5cdC8vIGFuZCBiZWNhdXNlIHdlIHJlbHkgb24gYSBsaWJyYXJ5IHRoYXQgb3BlcmF0ZXMgb3V0c2lkZSB0aGUgQW5ndWxhciB2aWV3IG9mIHRoZSB3b3JsZFxuXHQvLyB3ZSBuZWVkIHRvIGtlZXAgdHJ5aW5nIHRvIGxvYWQgdGhlIGxpYnJhcnksIHVudGlsIHRoZSByZWxldmFudCBET00gaXMgYWN0dWFsbHkgbGl2ZVxuXHRuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG5cdFx0aWYgKCF0aGlzLmlzRmxhdHBpY2tyTG9hZGVkKCkpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgdHMgaXMgdW5oYXBweSB3aXRoIHRoZSBiZWxvdyBjYWxsIHRvIGBmbGF0cGlja3JgXG5cdFx0XHR0aGlzLmZsYXRwaWNrckluc3RhbmNlID0gZmxhdHBpY2tyKGAjJHt0aGlzLmlkfS1pbnB1dGAsIHRoaXMuZmxhdHBpY2tyT3B0aW9ucyk7XG5cdFx0XHQvLyBpZiAoYW5kIG9ubHkgaWYpIHRoZSBpbml0aWFsaXphdGlvbiBzdWNjZWVkZWQsIHdlIGNhbiBzZXQgdGhlIGRhdGUgdmFsdWVzXG5cdFx0XHRpZiAodGhpcy5pc0ZsYXRwaWNrckxvYWRlZCgpKSB7XG5cdFx0XHRcdGlmICh0aGlzLnZhbHVlLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR0aGlzLnNldERhdGVWYWx1ZXModGhpcy52YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRASG9zdExpc3RlbmVyKFwiZm9jdXNpblwiKVxuXHRvbkZvY3VzKCkge1xuXHRcdC8vIFVwZGF0ZXMgdGhlIG1vbnRoIG1hbnVhbGx5IHdoZW4gY2FsZW5kYXIgbW9kZSBpcyByYW5nZSBiZWNhdXNlIG1vbnRoXG5cdFx0Ly8gd2lsbCBub3QgdXBkYXRlIHByb3Blcmx5IHdpdGhvdXQgbWFudWFsbHkgdXBkYXRpbmcgdGhlbSBvbiBmb2N1cy5cblx0XHRpZiAodGhpcy5yYW5nZSkge1xuXHRcdFx0aWYgKHRoaXMucmFuZ2VJbnB1dC5pbnB1dC5uYXRpdmVFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1sxXSkge1xuXHRcdFx0XHRjb25zdCBjdXJyZW50TW9udGggPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMV0uZ2V0TW9udGgoKTtcblx0XHRcdFx0dGhpcy5mbGF0cGlja3JJbnN0YW5jZS5jaGFuZ2VNb250aChjdXJyZW50TW9udGgsIGZhbHNlKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5pbnB1dC5pbnB1dC5uYXRpdmVFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1swXSkge1xuXHRcdFx0XHRjb25zdCBjdXJyZW50TW9udGggPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0TW9udGgoKTtcblx0XHRcdFx0dGhpcy5mbGF0cGlja3JJbnN0YW5jZS5jaGFuZ2VNb250aChjdXJyZW50TW9udGgsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRASG9zdExpc3RlbmVyKFwiZm9jdXNvdXRcIilcblx0b25Gb2N1c091dCgpIHtcblx0XHR0aGlzLm9uVG91Y2hlZCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdyaXRlcyBhIHZhbHVlIGZyb20gdGhlIG1vZGVsIHRvIHRoZSBjb21wb25lbnQuIEV4cGVjdHMgdGhlIHZhbHVlIHRvIGJlIGBudWxsYCBvciBgKERhdGUgfCBzdHJpbmcpW11gXG5cdCAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSByZWNlaXZlZCBmcm9tIHRoZSBtb2RlbFxuXHQgKi9cblx0d3JpdGVWYWx1ZSh2YWx1ZTogKERhdGUgfCBzdHJpbmcpW10pIHtcblx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRpZiAodGhpcy5pc0ZsYXRwaWNrckxvYWRlZCgpICYmIHRoaXMuZmxhdHBpY2tySW5zdGFuY2UuY29uZmlnKSB7XG5cdFx0XHRcdHRoaXMuc2V0RGF0ZVZhbHVlcyh0aGlzLnZhbHVlKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBgQ29udHJvbFZhbHVlQWNjZXNzb3JgIG1ldGhvZCB0byBwcm9ncmFtbWF0aWNhbGx5IGRpc2FibGUgdGhlIERhdGVQaWNrZXIuXG5cdCAqXG5cdCAqIGV4OiBgdGhpcy5mb3JtR3JvdXAuZ2V0KFwibXlEYXRlUGlja2VyXCIpLmRpc2FibGUoKTtgXG5cdCAqXG5cdCAqIEBwYXJhbSBpc0Rpc2FibGVkIGB0cnVlYCB0byBkaXNhYmxlIHRoZSBEYXRlUGlja2VyXG5cdCAqL1xuXHRzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pIHtcblx0XHR0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcblx0fVxuXG5cdHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSkge1xuXHRcdHRoaXMucHJvcGFnYXRlQ2hhbmdlID0gZm47XG5cdH1cblxuXHRyZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KSB7XG5cdFx0dGhpcy5vblRvdWNoZWQgPSBmbjtcblx0fVxuXG5cdG9uVG91Y2hlZDogKCkgPT4gYW55ID0gKCkgPT4geyB9O1xuXG5cdHByb3BhZ2F0ZUNoYW5nZSA9IChfOiBhbnkpID0+IHsgfTtcblxuXHQvKipcblx0ICogQ2xlYW5zIHVwIG91ciBmbGF0cGlja3IgaW5zdGFuY2Vcblx0ICovXG5cdG5nT25EZXN0cm95KCkge1xuXHRcdGlmICghdGhpcy5pc0ZsYXRwaWNrckxvYWRlZCgpKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuZmxhdHBpY2tySW5zdGFuY2UuZGVzdHJveSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgdGhlIGB2YWx1ZUNoYW5nZWAgZXZlbnQgZnJvbSB0aGUgcHJpbWFyeS9zaW5nbGUgaW5wdXRcblx0ICovXG5cdG9uVmFsdWVDaGFuZ2UoZXZlbnQ6IHN0cmluZykge1xuXHRcdGlmICh0aGlzLmlzRmxhdHBpY2tyTG9hZGVkKCkpIHtcblx0XHRcdGNvbnN0IGRhdGUgPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnBhcnNlRGF0ZShldmVudCwgdGhpcy5kYXRlRm9ybWF0KTtcblx0XHRcdGlmICh0aGlzLnJhbmdlKSB7XG5cdFx0XHRcdHRoaXMuc2V0RGF0ZVZhbHVlcyhbZGF0ZSwgdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVzWzFdXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNldERhdGVWYWx1ZXMoW2RhdGVdKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZG9TZWxlY3QodGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVzKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyB0aGUgYHZhbHVlQ2hhbmdlYCBldmVudCBmcm9tIHRoZSByYW5nZSBpbnB1dFxuXHQgKi9cblx0b25SYW5nZVZhbHVlQ2hhbmdlKGV2ZW50OiBzdHJpbmcpIHtcblx0XHRpZiAodGhpcy5pc0ZsYXRwaWNrckxvYWRlZCgpICYmIHRoaXMuZmxhdHBpY2tySW5zdGFuY2UuaXNPcGVuKSB7XG5cdFx0XHRjb25zdCBkYXRlID0gdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5wYXJzZURhdGUoZXZlbnQsIHRoaXMuZGF0ZUZvcm1hdCk7XG5cdFx0XHR0aGlzLnNldERhdGVWYWx1ZXMoW3RoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1swXSwgZGF0ZV0pO1xuXHRcdFx0dGhpcy5kb1NlbGVjdCh0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXMpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIG9wZW5pbmcgdGhlIGNhbGVuZGFyIFwicHJvcGVybHlcIiB3aGVuIHRoZSBjYWxlbmRhciBpY29uIGlzIGNsaWNrZWQuXG5cdCAqL1xuXHRvcGVuQ2FsZW5kYXIoZGF0ZXBpY2tlcklucHV0OiBEYXRlUGlja2VySW5wdXQpIHtcblx0XHRpZiAodGhpcy5yYW5nZSkge1xuXHRcdFx0ZGF0ZXBpY2tlcklucHV0LmlucHV0Lm5hdGl2ZUVsZW1lbnQuY2xpY2soKTtcblxuXHRcdFx0Ly8gSWYgdGhlIGZpcnN0IGlucHV0J3MgY2FsZW5kYXIgaWNvbiBpcyBjbGlja2VkIHdoZW4gY2FsZW5kYXIgaXMgaW4gcmFuZ2UgbW9kZSwgdGhlblxuXHRcdFx0Ly8gdGhlIG1vbnRoIGFuZCB5ZWFyIG5lZWRzIHRvIGJlIG1hbnVhbGx5IGNoYW5nZWQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0ZWQgbW9udGggYW5kXG5cdFx0XHQvLyB5ZWFyIG90aGVyd2lzZSB0aGUgY2FsZW5kYXIgdmlldyB3aWxsIG5vdCBiZSB1cGRhdGVkIHVwb24gb3BlbmluZy5cblx0XHRcdGlmIChkYXRlcGlja2VySW5wdXQgPT09IHRoaXMuaW5wdXQgJiYgdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVzWzBdKSB7XG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRNb250aCA9IHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1swXS5nZXRNb250aCgpO1xuXG5cdFx0XHRcdHRoaXMuZmxhdHBpY2tySW5zdGFuY2UuY3VycmVudFllYXIgPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0RnVsbFllYXIoKTtcblx0XHRcdFx0dGhpcy5mbGF0cGlja3JJbnN0YW5jZS5jaGFuZ2VNb250aChjdXJyZW50TW9udGgsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gU2luZ2xlLW1vZGUgZmxhdHBpY2tyIGhhbmRsZXMgbW91c2Vkb3duIGJ1dCBub3QgY2xpY2ssIHNvIG5hdGl2ZUVsZW1lbnQuY2xpY2soKSB3b24ndFxuXHRcdFx0Ly8gd29yayB3aGVuIHRoZSBjYWxlbmRhciBpY29uIGlzIGNsaWNrZWQuIEluIHRoaXMgY2FzZSB3ZSBzaW1wbHkgdXNlIGZsYXRwaWNrci5vcGVuKCkuXG5cdFx0XHR0aGlzLmZsYXRwaWNrckluc3RhbmNlLm9wZW4oKTtcblx0XHR9XG5cdH1cblxuXHRwcm90ZWN0ZWQgdXBkYXRlQ2FsZW5kYXJMaXN0ZW5lcnMoKSB7XG5cdFx0Y29uc3QgY2FsZW5kYXJDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmZsYXRwaWNrci1jYWxlbmRhclwiKTtcblx0XHRBcnJheS5mcm9tKGNhbGVuZGFyQ29udGFpbmVyKS5mb3JFYWNoKGNhbGVuZGFyID0+IHtcblx0XHRcdGNhbGVuZGFyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLnByZXZlbnRDYWxlbmRhckNsb3NlKTtcblx0XHRcdGNhbGVuZGFyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLnByZXZlbnRDYWxlbmRhckNsb3NlKTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIHRoZSBpbml0aWFsaXphdGlvbiBvZiBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSBkYXRlcGlja2VyIGlucHV0IGFuZCByYW5nZSBpbnB1dCBmaWVsZHMuXG5cdCAqL1xuXHRwcm90ZWN0ZWQgYWRkSW5wdXRMaXN0ZW5lcnMoKSB7XG5cdFx0aWYgKCF0aGlzLmlzRmxhdHBpY2tyTG9hZGVkKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBBbGxvd3MgZm9jdXMgdHJhbnNpdGlvbiBmcm9tIHRoZSBkYXRlcGlja2VyIGlucHV0IG9yIHJhbmdlIGlucHV0IGZpZWxkIHRvXG5cdFx0Ly8gZmxhdHBpY2tyIGNhbGVuZGFyIHVzaW5nIGEga2V5Ym9hcmQuXG5cdFx0Y29uc3QgYWRkRm9jdXNDYWxlbmRhckxpc3RlbmVyID0gKGVsZW1lbnQ6IEhUTUxJbnB1dEVsZW1lbnQpID0+IHtcblx0XHRcdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB7XG5cdFx0XHRcdGlmIChldmVudC5rZXkgPT09IFwiRXNjYXBlXCIpIHtcblx0XHRcdFx0XHR0aGlzLmZsYXRwaWNrckluc3RhbmNlLmNsb3NlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGV2ZW50LmtleSA9PT0gXCJBcnJvd0Rvd25cIikge1xuXHRcdFx0XHRcdGlmICghdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5pc09wZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uub3BlbigpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IGNhbGVuZGFyQ29udGFpbmVyID0gdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5jYWxlbmRhckNvbnRhaW5lcjtcblx0XHRcdFx0XHRjb25zdCBkYXlFbGVtZW50ID0gY2FsZW5kYXJDb250YWluZXIgJiYgY2FsZW5kYXJDb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5mbGF0cGlja3ItZGF5W3RhYmluZGV4XVwiKTtcblxuXHRcdFx0XHRcdGlmIChkYXlFbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRkYXlFbGVtZW50LmZvY3VzKCk7XG5cblx0XHRcdFx0XHRcdC8vIElmIHRoZSB1c2VyIG1hbnVhbGx5IGlucHV0cyBhIHZhbHVlIGludG8gdGhlIGRhdGUgZmllbGQgYW5kIHByZXNzZXMgYXJyb3cgZG93bixcblx0XHRcdFx0XHRcdC8vIGRhdGVwaWNrZXIgaW5wdXQgb25jaGFuZ2Ugd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiBmb2N1cyBpcyByZW1vdmVkIGZyb20gaXQgYW5kXG5cdFx0XHRcdFx0XHQvLyBgZmxhdHBpY2tySW5zdGFuY2Uuc2V0RGF0ZWAgYW5kIGBmbGF0cGlja3JJbnN0YW5jZS5jaGFuZ2VNb250aGAgd2lsbCBiZSBpbnZva2VkXG5cdFx0XHRcdFx0XHQvLyB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgY2hhbmdlIGZvY3VzIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRvY3VtZW50LlxuXHRcdFx0XHRcdFx0aWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGRheUVsZW1lbnQgJiYgdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVFbGVtKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlRWxlbS5mb2N1cygpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fTtcblxuXHRcdGlmICh0aGlzLmlucHV0ICYmIHRoaXMuaW5wdXQuaW5wdXQpIHtcblx0XHRcdGFkZEZvY3VzQ2FsZW5kYXJMaXN0ZW5lcih0aGlzLmlucHV0LmlucHV0Lm5hdGl2ZUVsZW1lbnQpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnJhbmdlSW5wdXQgJiYgdGhpcy5yYW5nZUlucHV0LmlucHV0KSB7XG5cdFx0XHRhZGRGb2N1c0NhbGVuZGFyTGlzdGVuZXIodGhpcy5yYW5nZUlucHV0LmlucHV0Lm5hdGl2ZUVsZW1lbnQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNldHMgdGhlIGZsYXRwaWNrciBpbnN0YW5jZSB3aGlsZSBrZWVwaW5nIHRoZSBkYXRlIHZhbHVlcyAob3IgdXBkYXRpbmcgdGhlbSBpZiBuZXdEYXRlcyBpcyBwcm92aWRlZClcblx0ICpcblx0ICogVXNlZCB0byBwaWNrIHVwIGlucHV0IGNoYW5nZXMgb3IgbG9jYWxlIGNoYW5nZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSBuZXdEYXRlcyBBbiBvcHRpb25hbCBTaW1wbGVDaGFuZ2Ugb2YgZGF0ZSB2YWx1ZXNcblx0ICovXG5cdHByb3RlY3RlZCByZXNldEZsYXRwaWNrckluc3RhbmNlKG5ld0RhdGVzPzogU2ltcGxlQ2hhbmdlKSB7XG5cdFx0aWYgKHRoaXMuaXNGbGF0cGlja3JMb2FkZWQoKSkge1xuXHRcdFx0bGV0IGRhdGVzID0gdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVzO1xuXHRcdFx0aWYgKG5ld0RhdGVzICYmIHRoaXMuZGlkRGF0ZVZhbHVlQ2hhbmdlKG5ld0RhdGVzLmN1cnJlbnRWYWx1ZSwgbmV3RGF0ZXMucHJldmlvdXNWYWx1ZSkpIHtcblx0XHRcdFx0ZGF0ZXMgPSBuZXdEYXRlcy5jdXJyZW50VmFsdWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBvbmx5IHJlc2V0IHRoZSBmbGF0cGlja3IgaW5zdGFuY2Ugb24gSW5wdXQgY2hhbmdlc1xuXHRcdFx0Ly8gQHRzLWlnbm9yZSB0cyBpcyB1bmhhcHB5IHdpdGggdGhlIGJlbG93IGNhbGwgdG8gYGZsYXRwaWNrcmBcblx0XHRcdHRoaXMuZmxhdHBpY2tySW5zdGFuY2UgPSBmbGF0cGlja3IoYCMke3RoaXMuaWR9LWlucHV0YCwgdGhpcy5mbGF0cGlja3JPcHRpb25zKTtcblx0XHRcdHRoaXMuc2V0RGF0ZVZhbHVlcyhkYXRlcyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENhcmJvbiB1c2VzIGEgbnVtYmVyIG9mIHNwZWNpZmljIGNsYXNzbmFtZXMgZm9yIHBhcnRzIG9mIHRoZSBmbGF0cGlja3IgLSB0aGlzIGlkZW1wb3RlbnQgbWV0aG9kIGFwcGxpZXMgdGhlbSBpZiBuZWVkZWQuXG5cdCAqL1xuXHRwcm90ZWN0ZWQgdXBkYXRlQ2xhc3NOYW1lcygpIHtcblx0XHRpZiAoIXRoaXMuZWxlbWVudFJlZikgeyByZXR1cm47IH1cblx0XHQvLyBnZXQgYWxsIHRoZSBwb3NzaWJsZSBmbGF0cGlja3JzIGluIHRoZSBkb2N1bWVudCAtIHdlIG5lZWQgdG8gYWRkIGNsYXNzZXMgdG8gKHBvdGVudGlhbGx5KSBhbGwgb2YgdGhlbVxuXHRcdGNvbnN0IGNhbGVuZGFyQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5mbGF0cGlja3ItY2FsZW5kYXJcIik7XG5cdFx0Y29uc3QgbW9udGhDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmZsYXRwaWNrci1tb250aFwiKTtcblx0XHRjb25zdCB3ZWVrZGF5c0NvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuZmxhdHBpY2tyLXdlZWtkYXlzXCIpO1xuXHRcdGNvbnN0IHdlZWtkYXlDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmZsYXRwaWNrci13ZWVrZGF5XCIpO1xuXHRcdGNvbnN0IGRheXNDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmZsYXRwaWNrci1kYXlzXCIpO1xuXHRcdGNvbnN0IGRheUNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuZmxhdHBpY2tyLWRheVwiKTtcblxuXHRcdC8vIGFkZCBjbGFzc2VzIHRvIGxpc3RzIG9mIGVsZW1lbnRzXG5cdFx0Y29uc3QgYWRkQ2xhc3NJZk5vdEV4aXN0cyA9IChjbGFzc25hbWU6IHN0cmluZywgZWxlbWVudExpc3Q6IE5vZGVMaXN0T2Y8RWxlbWVudD4pID0+IHtcblx0XHRcdEFycmF5LmZyb20oZWxlbWVudExpc3QpLmZvckVhY2goZWxlbWVudCA9PiB7XG5cdFx0XHRcdGlmICghZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NuYW1lKSkge1xuXHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc25hbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0Ly8gYWRkIGNsYXNzZXMgKGJ1dCBvbmx5IGlmIHRoZXkgZG9uJ3QgZXhpc3QsIHNtYWxsIHBlcmYgd2luKVxuXHRcdGFkZENsYXNzSWZOb3RFeGlzdHMoXCJjZHMtLWRhdGUtcGlja2VyX19jYWxlbmRhclwiLCBjYWxlbmRhckNvbnRhaW5lcik7XG5cdFx0YWRkQ2xhc3NJZk5vdEV4aXN0cyhcImNkcy0tZGF0ZS1waWNrZXJfX21vbnRoXCIsIG1vbnRoQ29udGFpbmVyKTtcblx0XHRhZGRDbGFzc0lmTm90RXhpc3RzKFwiY2RzLS1kYXRlLXBpY2tlcl9fd2Vla2RheXNcIiwgd2Vla2RheXNDb250YWluZXIpO1xuXHRcdGFkZENsYXNzSWZOb3RFeGlzdHMoXCJjZHMtLWRhdGUtcGlja2VyX19kYXlzXCIsIGRheXNDb250YWluZXIpO1xuXG5cdFx0Ly8gYWRkIHdlZWtkYXkgY2xhc3NlcyBhbmQgZm9ybWF0IHRoZSB0ZXh0XG5cdFx0QXJyYXkuZnJvbSh3ZWVrZGF5Q29udGFpbmVyKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuXHRcdFx0ZWxlbWVudC5pbm5lckhUTUwgPSBlbGVtZW50LmlubmVySFRNTC5yZXBsYWNlKC9cXHMrL2csIFwiXCIpO1xuXHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiY2RzLS1kYXRlLXBpY2tlcl9fd2Vla2RheVwiKTtcblx0XHR9KTtcblxuXHRcdC8vIGFkZCBkYXkgY2xhc3NlcyBhbmQgc3BlY2lhbCBjYXNlIHRoZSBcInRvZGF5XCIgZWxlbWVudCBiYXNlZCBvbiBgdGhpcy52YWx1ZWBcblx0XHRBcnJheS5mcm9tKGRheUNvbnRhaW5lcikuZm9yRWFjaChlbGVtZW50ID0+IHtcblx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImNkcy0tZGF0ZS1waWNrZXJfX2RheVwiKTtcblx0XHRcdGlmICghdGhpcy52YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJ0b2RheVwiKSAmJiB0aGlzLnZhbHVlLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibm8tYm9yZGVyXCIpO1xuXHRcdFx0fSBlbHNlIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcInRvZGF5XCIpICYmIHRoaXMudmFsdWUubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcIm5vLWJvcmRlclwiKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdHByb3RlY3RlZCB1cGRhdGVBdHRyaWJ1dGVzKCkge1xuXHRcdGNvbnN0IGNhbGVuZGFyQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5mbGF0cGlja3ItY2FsZW5kYXJcIik7XG5cdFx0QXJyYXkuZnJvbShjYWxlbmRhckNvbnRhaW5lcikuZm9yRWFjaChjYWxlbmRhciA9PiB7XG5cdFx0XHRjYWxlbmRhci5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicmVnaW9uXCIpO1xuXHRcdFx0Y2FsZW5kYXIuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0aGlzLmFyaWFMYWJlbCk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgZ2l2ZW4gZGF0ZSB2YWx1ZSBhcnJheSB0byBib3RoIHRoZSBmbGF0cGlja3IgaW5zdGFuY2UgYW5kIHRoZSBgaW5wdXRgKHMpXG5cdCAqIEBwYXJhbSBkYXRlcyB0aGUgZGF0ZSB2YWx1ZXMgdG8gYXBwbHlcblx0ICovXG5cdHByb3RlY3RlZCBzZXREYXRlVmFsdWVzKGRhdGVzOiAoRGF0ZSB8IHN0cmluZylbXSkge1xuXHRcdGlmICh0aGlzLmlzRmxhdHBpY2tyTG9hZGVkKCkpIHtcblx0XHRcdGNvbnN0IHNpbmdsZUlucHV0ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihgIyR7dGhpcy5pZH0taW5wdXRgKTtcblx0XHRcdGNvbnN0IHJhbmdlSW5wdXQgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKGAjJHt0aGlzLmlkfS1yYW5nZUlucHV0YCk7XG5cblx0XHRcdC8vIGBmbGF0cGlja3JJbnN0YW5jZS5zZXREYXRlYCByZW1vdmVzIHRoZSBmb2N1cyBvbiB0aGUgc2VsZWN0ZWQgZGF0ZSBlbGVtZW50IGFuZCB3aWxsXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGNoYW5nZSBmb2N1cyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkb2N1bWVudC4gSWYgYSBzZWxlY3RlZCBkYXRlIGlzXG5cdFx0XHQvLyBmb2N1c2VkIGJlZm9yZSBgZmxhdHBpY2tySW5zdGFuY2Uuc2V0RGF0ZWAgaXMgaW52b2tlZCB0aGVuIGl0IHNob3VsZCByZW1haW4gZm9jdXNlZC5cblx0XHRcdGxldCBzaG91bGRSZWZvY3VzRGF0ZUVsZW1lbnQgPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZUVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cblx0XHRcdC8vIHNldCB0aGUgZGF0ZSBvbiB0aGUgaW5zdGFuY2Vcblx0XHRcdHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2V0RGF0ZShkYXRlcyk7XG5cblx0XHRcdGlmIChzaG91bGRSZWZvY3VzRGF0ZUVsZW1lbnQpIHtcblx0XHRcdFx0dGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVFbGVtLmZvY3VzKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHdlIGNhbiBlaXRoZXIgc2V0IGEgZGF0ZSB2YWx1ZSBvciBhbiBlbXB0eSBzdHJpbmcsIHNvIHdlIHN0YXJ0IHdpdGggYW4gZW1wdHkgc3RyaW5nXG5cdFx0XHRsZXQgc2luZ2xlRGF0ZSA9IFwiXCI7XG5cdFx0XHQvLyBpZiBkYXRlIGlzIGEgc3RyaW5nLCBwYXJzZSBhbmQgZm9ybWF0XG5cdFx0XHRpZiAodHlwZW9mIHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1swXSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRzaW5nbGVEYXRlID0gdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5wYXJzZURhdGUodGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVzWzBdLCB0aGlzLmRhdGVGb3JtYXQpO1xuXHRcdFx0XHRzaW5nbGVEYXRlID0gdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5mb3JtYXREYXRlKHNpbmdsZURhdGUsIHRoaXMuZGF0ZUZvcm1hdCk7XG5cdFx0XHQvLyBpZiBkYXRlIGlzIG5vdCBhIHN0cmluZyB3ZSBjYW4gYXNzdW1lIGl0J3MgYSBEYXRlIGFuZCB3ZSBzaG91bGQgZm9ybWF0XG5cdFx0XHR9IGVsc2UgaWYgKCEhdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVzWzBdKSB7XG5cdFx0XHRcdHNpbmdsZURhdGUgPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLmZvcm1hdERhdGUodGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVzWzBdLCB0aGlzLmRhdGVGb3JtYXQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmFuZ2VJbnB1dCkge1xuXHRcdFx0XHQvLyB3ZSBjYW4gZWl0aGVyIHNldCBhIGRhdGUgdmFsdWUgb3IgYW4gZW1wdHkgc3RyaW5nLCBzbyB3ZSBzdGFydCB3aXRoIGFuIGVtcHR5IHN0cmluZ1xuXHRcdFx0XHRsZXQgcmFuZ2VEYXRlID0gXCJcIjtcblx0XHRcdFx0Ly8gaWYgZGF0ZSBpcyBhIHN0cmluZywgcGFyc2UgYW5kIGZvcm1hdFxuXHRcdFx0XHRpZiAodHlwZW9mIHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1sxXSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdHJhbmdlRGF0ZSA9IHRoaXMuZmxhdHBpY2tySW5zdGFuY2UucGFyc2VEYXRlKHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1sxXS50b1N0cmluZygpLCB0aGlzLmRhdGVGb3JtYXQpO1xuXHRcdFx0XHRcdHJhbmdlRGF0ZSA9IHRoaXMuZmxhdHBpY2tySW5zdGFuY2UuZm9ybWF0RGF0ZShyYW5nZURhdGUsIHRoaXMuZGF0ZUZvcm1hdCk7XG5cdFx0XHRcdC8vIGlmIGRhdGUgaXMgbm90IGEgc3RyaW5nIHdlIGNhbiBhc3N1bWUgaXQncyBhIERhdGUgYW5kIHdlIHNob3VsZCBmb3JtYXRcblx0XHRcdFx0fSBlbHNlIGlmICghIXRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1sxXSkge1xuXHRcdFx0XHRcdHJhbmdlRGF0ZSA9IHRoaXMuZmxhdHBpY2tySW5zdGFuY2UuZm9ybWF0RGF0ZSh0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMV0sIHRoaXMuZGF0ZUZvcm1hdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0Ly8gYXBwbHkgdGhlIHZhbHVlc1xuXHRcdFx0XHRcdHJhbmdlSW5wdXQudmFsdWUgPSByYW5nZURhdGU7XG5cdFx0XHRcdFx0c2luZ2xlSW5wdXQudmFsdWUgPSBzaW5nbGVEYXRlO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwcm90ZWN0ZWQgcHJldmVudENhbGVuZGFyQ2xvc2UgPSBldmVudCA9PiBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRwcm90ZWN0ZWQgZG9TZWxlY3Qoc2VsZWN0ZWRWYWx1ZTogKERhdGUgfCBzdHJpbmcpW10pIHtcblx0XHQvLyBJbiByYW5nZSBtb2RlLCBpZiBhIGRhdGUgaXMgc2VsZWN0ZWQgZnJvbSB0aGUgZmlyc3QgY2FsZW5kYXIgdGhhdCBpcyBmcm9tIHRoZSBwcmV2aW91cyBtb250aCxcblx0XHQvLyB0aGUgbW9udGggd2lsbCBub3QgYmUgdXBkYXRlZCBvbiB0aGUgY2FsZW5kYXIgdW50aWwgdGhlIGNhbGVuZGFyIGlzIHJlLW9wZW5lZC5cblx0XHQvLyBUaGlzIHdpbGwgbWFrZSBzdXJlIHRoZSBjYWxlbmRhciBpcyB1cGRhdGVkIHdpdGggdGhlIGNvcnJlY3QgbW9udGguXG5cdFx0aWYgKHRoaXMucmFuZ2UgJiYgdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVzWzBdKSB7XG5cdFx0XHRjb25zdCBjdXJyZW50TW9udGggPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0TW9udGgoKTtcblxuXHRcdFx0Ly8gYGZsYXRwaWNrckluc3RhbmNlLmNoYW5nZU1vbnRoYCByZW1vdmVzIHRoZSBmb2N1cyBvbiB0aGUgc2VsZWN0ZWQgZGF0ZSBlbGVtZW50IGFuZCB3aWxsXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGNoYW5nZSBmb2N1cyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkb2N1bWVudC4gSWYgYSBzZWxlY3RlZCBkYXRlIGlzXG5cdFx0XHQvLyBmb2N1c2VkIGJlZm9yZSBgZmxhdHBpY2tySW5zdGFuY2UuY2hhbmdlTW9udGhgIGlzIGludm9rZWQgdGhlbiBpdCBzaG91bGQgcmVtYWluIGZvY3VzZWQuXG5cdFx0XHRsZXQgc2hvdWxkUmVmb2N1c0RhdGVFbGVtZW50ID0gdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVFbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG5cdFx0XHR0aGlzLmZsYXRwaWNrckluc3RhbmNlLmNoYW5nZU1vbnRoKGN1cnJlbnRNb250aCwgZmFsc2UpO1xuXG5cdFx0XHRpZiAoc2hvdWxkUmVmb2N1c0RhdGVFbGVtZW50KSB7XG5cdFx0XHRcdHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlRWxlbS5mb2N1cygpO1xuXHRcdFx0fVxuXG5cdFx0fVxuXHRcdHRoaXMudmFsdWVDaGFuZ2UuZW1pdChzZWxlY3RlZFZhbHVlKTtcblx0XHR0aGlzLnByb3BhZ2F0ZUNoYW5nZShzZWxlY3RlZFZhbHVlKTtcblx0fVxuXG5cdHByb3RlY3RlZCBkaWREYXRlVmFsdWVDaGFuZ2UoY3VycmVudFZhbHVlLCBwcmV2aW91c1ZhbHVlKSB7XG5cdFx0cmV0dXJuIGN1cnJlbnRWYWx1ZVswXSAhPT0gcHJldmlvdXNWYWx1ZVswXSB8fCBjdXJyZW50VmFsdWVbMV0gIT09IHByZXZpb3VzVmFsdWVbMV07XG5cdH1cblxuXHQvKipcblx0ICogTW9yZSBhZHZhbmNlZCBjaGVja2luZyBvZiB0aGUgbG9hZGVkIHN0YXRlIG9mIGZsYXRwaWNrclxuXHQgKi9cblx0cHJvdGVjdGVkIGlzRmxhdHBpY2tyTG9hZGVkKCkge1xuXHRcdC8vIGNhc3QgdGhlIGluc3RhbmNlIHRvIGEgYm9vbGVhbiwgYW5kIHNvbWUgbWV0aG9kIHRoYXQgaGFzIHRvIGV4aXN0IGZvciB0aGUgbGlicmFyeSB0byBiZSBsb2FkZWQgaW4gdGhpcyBjYXNlIGBzZXREYXRlYFxuXHRcdHJldHVybiAhIXRoaXMuZmxhdHBpY2tySW5zdGFuY2UgJiYgISF0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNldERhdGU7XG5cdH1cblxuXHQvKipcblx0ICogUmlnaHQgYXJyb3cgSFRNTCBwYXNzZWQgdG8gZmxhdHBpY2tyXG5cdCAqL1xuXHRwcm90ZWN0ZWQgcmlnaHRBcnJvd0hUTUwoKSB7XG5cdFx0cmV0dXJuIGBcblx0XHRcdDxzdmcgd2lkdGg9XCIxNnB4XCIgaGVpZ2h0PVwiMTZweFwiIHZpZXdCb3g9XCIwIDAgMTYgMTZcIj5cblx0XHRcdFx0PHBvbHlnb24gcG9pbnRzPVwiMTEsOCA2LDEzIDUuMywxMi4zIDkuNiw4IDUuMywzLjcgNiwzIFwiLz5cblx0XHRcdFx0PHJlY3Qgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgc3R5bGU9XCJmaWxsOm5vbmVcIiAvPlxuXHRcdFx0PC9zdmc+YDtcblx0fVxuXG5cdC8qKlxuXHQgKiBMZWZ0IGFycm93IEhUTUwgcGFzc2VkIHRvIGZsYXRwaWNrclxuXHQgKi9cblx0cHJvdGVjdGVkIGxlZnRBcnJvd0hUTUwoKSB7XG5cdFx0cmV0dXJuIGBcblx0XHRcdDxzdmcgd2lkdGg9XCIxNnB4XCIgaGVpZ2h0PVwiMTZweFwiIHZpZXdCb3g9XCIwIDAgMTYgMTZcIj5cblx0XHRcdFx0PHBvbHlnb24gcG9pbnRzPVwiNSw4IDEwLDMgMTAuNywzLjcgNi40LDggMTAuNywxMi4zIDEwLDEzIFwiLz5cblx0XHRcdFx0PHJlY3Qgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgc3R5bGU9XCJmaWxsOm5vbmVcIiAvPlxuXHRcdFx0PC9zdmc+YDtcblx0fVxufVxuIl19