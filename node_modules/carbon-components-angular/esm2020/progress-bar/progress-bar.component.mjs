import { Component, HostBinding, Input, TemplateRef } from "@angular/core";
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "carbon-components-angular/icon";
/**
 * Get started with importing the module:
 *
 * ```typescript
 * import { ProgressBarModule } from 'carbon-components-angular';
 * ```
 *
 * [See demo](../../?path=/story/components-progress-bar--basic)
 */
export class ProgressBar {
    constructor() {
        this.id = `progress-bar-${ProgressBar.progressBarCounter++}`;
        this.helperId = `progress-bar-helper-${ProgressBar.progressBarCounter}`;
        /**
         * Maximum value
         */
        this.max = 100;
        /**
         * Alignment variant of the progress bar, default is `default`
         */
        this.type = "default";
        /**
         * Current status of the progress bar, default is `active`
         */
        this.status = "active";
        /**
         * Size of the progress bar, default is `big`
         */
        this.size = "big";
        this.defaultClass = true;
        this._value = undefined;
    }
    /**
     * Current value
     */
    set value(num) {
        this._value = num;
        // Validate number
        if (num > this.max) {
            this._value = this.max;
        }
        if (num < 0) {
            this._value = 0;
        }
        // Set values based on current state
        if (this.isError) {
            this._value = 0;
        }
        else if (this.isFinished) {
            this._value = this.max;
        }
    }
    get value() {
        return this._value;
    }
    get percentage() {
        return `scaleX(${this.value / this.max})`;
    }
    // Size
    get bigBar() {
        return this.size === "big";
    }
    get smallBar() {
        return this.size === "small";
    }
    // Type
    get defaultType() {
        return this.type === "default";
    }
    get indentedType() {
        return this.type === "indented";
    }
    get inlineType() {
        return this.type === "inline";
    }
    // Status
    get isFinished() {
        return this.status === "finished";
    }
    get isError() {
        return this.status === "error";
    }
    get indeterminate() {
        return this.value === undefined && !this.isFinished && !this.isError;
    }
    isTemplate(value) {
        return value instanceof TemplateRef;
    }
}
ProgressBar.progressBarCounter = 0;
ProgressBar.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ProgressBar, deps: [], target: i0.ɵɵFactoryTarget.Component });
ProgressBar.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: ProgressBar, selector: "cds-progress-bar, ibm-progress-bar", inputs: { value: "value", id: "id", label: "label", helperText: "helperText", max: "max", type: "type", status: "status", size: "size" }, host: { properties: { "class.cds--progress-bar--big": "this.bigBar", "class.cds--progress-bar--small": "this.smallBar", "class.cds--progress-bar--default": "this.defaultType", "class.cds--progress-bar--indented": "this.indentedType", "class.cds--progress-bar--inline": "this.inlineType", "class.cds--progress-bar--finished": "this.isFinished", "class.cds--progress-bar--error": "this.isError", "class.cds--progress-bar--indeterminate": "this.indeterminate", "class.cds--progress-bar": "this.defaultClass" } }, ngImport: i0, template: `
		<div
			*ngIf="label"
			class="cds--progress-bar__label"
			[id]="id">
			<span class="cds--progress-bar__label-text">
				<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
				<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
			</span>
			<svg
				*ngIf="isFinished"
				fill="currentColor"
				cdsIcon="checkmark--filled"
				class="cds--progress-bar__status-icon">
			</svg>
			<svg
				*ngIf="isError"
				fill="currentColor"
				cdsIcon="error--filled"
				class="cds--progress-bar__status-icon">
			</svg>
		</div>
		<div
			class="cds--progress-bar__track"
			role="progressbar"
			[attr.aria-invalid]="isError"
			[attr.labelledby]="id"
			[attr.describedby]="helperText ? helperId: null"
			[attr.aria-valuemin]="!indeterminate ? 0 : null"
			[attr.aria-valuemax]="!indeterminate ? max : null"
			[attr.aria-valuenow]="!indeterminate ? value : null">
			<div
				class="cds--progress-bar__bar"
				[ngStyle]="{
					'transform': !isFinished && !isError ? percentage : null
				}">
			</div>
		</div>
		<div
			[id]="helperId"
			*ngIf="helperText"
			class="cds--progress-bar__helper-text">
			<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
			<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
		</div>
	`, isInline: true, dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: i2.IconDirective, selector: "[cdsIcon], [ibmIcon]", inputs: ["ibmIcon", "cdsIcon", "size", "title", "ariaLabel", "ariaLabelledBy", "ariaHidden", "isFocusable"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ProgressBar, decorators: [{
            type: Component,
            args: [{
                    selector: "cds-progress-bar, ibm-progress-bar",
                    template: `
		<div
			*ngIf="label"
			class="cds--progress-bar__label"
			[id]="id">
			<span class="cds--progress-bar__label-text">
				<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
				<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
			</span>
			<svg
				*ngIf="isFinished"
				fill="currentColor"
				cdsIcon="checkmark--filled"
				class="cds--progress-bar__status-icon">
			</svg>
			<svg
				*ngIf="isError"
				fill="currentColor"
				cdsIcon="error--filled"
				class="cds--progress-bar__status-icon">
			</svg>
		</div>
		<div
			class="cds--progress-bar__track"
			role="progressbar"
			[attr.aria-invalid]="isError"
			[attr.labelledby]="id"
			[attr.describedby]="helperText ? helperId: null"
			[attr.aria-valuemin]="!indeterminate ? 0 : null"
			[attr.aria-valuemax]="!indeterminate ? max : null"
			[attr.aria-valuenow]="!indeterminate ? value : null">
			<div
				class="cds--progress-bar__bar"
				[ngStyle]="{
					'transform': !isFinished && !isError ? percentage : null
				}">
			</div>
		</div>
		<div
			[id]="helperId"
			*ngIf="helperText"
			class="cds--progress-bar__helper-text">
			<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
			<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
		</div>
	`
                }]
        }], propDecorators: { value: [{
                type: Input
            }], bigBar: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--big"]
            }], smallBar: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--small"]
            }], defaultType: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--default"]
            }], indentedType: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--indented"]
            }], inlineType: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--inline"]
            }], isFinished: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--finished"]
            }], isError: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--error"]
            }], indeterminate: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--indeterminate"]
            }], id: [{
                type: Input
            }], label: [{
                type: Input
            }], helperText: [{
                type: Input
            }], max: [{
                type: Input
            }], type: [{
                type: Input
            }], status: [{
                type: Input
            }], size: [{
                type: Input
            }], defaultClass: [{
                type: HostBinding,
                args: ["class.cds--progress-bar"]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3MtYmFyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wcm9ncmVzcy1iYXIvcHJvZ3Jlc3MtYmFyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULFdBQVcsRUFDWCxLQUFLLEVBQ0wsV0FBVyxFQUNYLE1BQU0sZUFBZSxDQUFDOzs7O0FBRXZCOzs7Ozs7OztHQVFHO0FBa0RILE1BQU0sT0FBTyxXQUFXO0lBakR4QjtRQTBHVSxPQUFFLEdBQUcsZ0JBQWdCLFdBQVcsQ0FBQyxrQkFBa0IsRUFBRSxFQUFFLENBQUM7UUFDakUsYUFBUSxHQUFHLHVCQUF1QixXQUFXLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQVNuRTs7V0FFRztRQUNNLFFBQUcsR0FBRyxHQUFHLENBQUM7UUFDbkI7O1dBRUc7UUFDTSxTQUFJLEdBQXNDLFNBQVMsQ0FBQztRQUM3RDs7V0FFRztRQUNNLFdBQU0sR0FBb0MsUUFBUSxDQUFDO1FBQzVEOztXQUVHO1FBQ00sU0FBSSxHQUFvQixLQUFLLENBQUM7UUFFQyxpQkFBWSxHQUFHLElBQUksQ0FBQztRQUNwRCxXQUFNLEdBQUcsU0FBUyxDQUFDO0tBSzNCO0lBekZBOztPQUVHO0lBQ0gsSUFBYSxLQUFLLENBQUMsR0FBdUI7UUFDekMsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUM7UUFDbEIsa0JBQWtCO1FBQ2xCLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDbkIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO1NBQ3ZCO1FBQ0QsSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFO1lBQ1osSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7U0FDaEI7UUFDRCxvQ0FBb0M7UUFDcEMsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2pCLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1NBQ2hCO2FBQU0sSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQzNCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztTQUN2QjtJQUNGLENBQUM7SUFFRCxJQUFJLEtBQUs7UUFDUixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDcEIsQ0FBQztJQUVELElBQUksVUFBVTtRQUNiLE9BQU8sVUFBVSxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUMzQyxDQUFDO0lBQ0QsT0FBTztJQUNQLElBQWlELE1BQU07UUFDdEQsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLEtBQUssQ0FBQztJQUM1QixDQUFDO0lBQ0QsSUFBbUQsUUFBUTtRQUMxRCxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssT0FBTyxDQUFDO0lBQzlCLENBQUM7SUFDRCxPQUFPO0lBQ1AsSUFBcUQsV0FBVztRQUMvRCxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDO0lBQ2hDLENBQUM7SUFDRCxJQUFzRCxZQUFZO1FBQ2pFLE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxVQUFVLENBQUM7SUFDakMsQ0FBQztJQUNELElBQW9ELFVBQVU7UUFDN0QsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQztJQUMvQixDQUFDO0lBQ0QsU0FBUztJQUNULElBQXNELFVBQVU7UUFDL0QsT0FBTyxJQUFJLENBQUMsTUFBTSxLQUFLLFVBQVUsQ0FBQztJQUNuQyxDQUFDO0lBQ0QsSUFBbUQsT0FBTztRQUN6RCxPQUFPLElBQUksQ0FBQyxNQUFNLEtBQUssT0FBTyxDQUFDO0lBQ2hDLENBQUM7SUFDRCxJQUEyRCxhQUFhO1FBQ3ZFLE9BQU8sSUFBSSxDQUFDLEtBQUssS0FBSyxTQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN0RSxDQUFDO0lBaUNELFVBQVUsQ0FBQyxLQUFLO1FBQ2YsT0FBTyxLQUFLLFlBQVksV0FBVyxDQUFDO0lBQ3JDLENBQUM7O0FBbENNLDhCQUFrQixHQUFHLENBQUMsQ0FBQzt3R0F2RGxCLFdBQVc7NEZBQVgsV0FBVyxrdEJBL0NiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUE2Q1Q7MkZBRVcsV0FBVztrQkFqRHZCLFNBQVM7bUJBQUM7b0JBQ1YsUUFBUSxFQUFFLG9DQUFvQztvQkFDOUMsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUE2Q1Q7aUJBQ0Q7OEJBS2EsS0FBSztzQkFBakIsS0FBSztnQkF5QjJDLE1BQU07c0JBQXRELFdBQVc7dUJBQUMsOEJBQThCO2dCQUdRLFFBQVE7c0JBQTFELFdBQVc7dUJBQUMsZ0NBQWdDO2dCQUlRLFdBQVc7c0JBQS9ELFdBQVc7dUJBQUMsa0NBQWtDO2dCQUdPLFlBQVk7c0JBQWpFLFdBQVc7dUJBQUMsbUNBQW1DO2dCQUdJLFVBQVU7c0JBQTdELFdBQVc7dUJBQUMsaUNBQWlDO2dCQUlRLFVBQVU7c0JBQS9ELFdBQVc7dUJBQUMsbUNBQW1DO2dCQUdHLE9BQU87c0JBQXpELFdBQVc7dUJBQUMsZ0NBQWdDO2dCQUdjLGFBQWE7c0JBQXZFLFdBQVc7dUJBQUMsd0NBQXdDO2dCQUs1QyxFQUFFO3NCQUFWLEtBQUs7Z0JBS0csS0FBSztzQkFBYixLQUFLO2dCQUlHLFVBQVU7c0JBQWxCLEtBQUs7Z0JBSUcsR0FBRztzQkFBWCxLQUFLO2dCQUlHLElBQUk7c0JBQVosS0FBSztnQkFJRyxNQUFNO3NCQUFkLEtBQUs7Z0JBSUcsSUFBSTtzQkFBWixLQUFLO2dCQUVrQyxZQUFZO3NCQUFuRCxXQUFXO3VCQUFDLHlCQUF5QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0SG9zdEJpbmRpbmcsXG5cdElucHV0LFxuXHRUZW1wbGF0ZVJlZlxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuXG4vKipcbiAqIEdldCBzdGFydGVkIHdpdGggaW1wb3J0aW5nIHRoZSBtb2R1bGU6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgUHJvZ3Jlc3NCYXJNb2R1bGUgfSBmcm9tICdjYXJib24tY29tcG9uZW50cy1hbmd1bGFyJztcbiAqIGBgYFxuICpcbiAqIFtTZWUgZGVtb10oLi4vLi4vP3BhdGg9L3N0b3J5L2NvbXBvbmVudHMtcHJvZ3Jlc3MtYmFyLS1iYXNpYylcbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiBcImNkcy1wcm9ncmVzcy1iYXIsIGlibS1wcm9ncmVzcy1iYXJcIixcblx0dGVtcGxhdGU6IGBcblx0XHQ8ZGl2XG5cdFx0XHQqbmdJZj1cImxhYmVsXCJcblx0XHRcdGNsYXNzPVwiY2RzLS1wcm9ncmVzcy1iYXJfX2xhYmVsXCJcblx0XHRcdFtpZF09XCJpZFwiPlxuXHRcdFx0PHNwYW4gY2xhc3M9XCJjZHMtLXByb2dyZXNzLWJhcl9fbGFiZWwtdGV4dFwiPlxuXHRcdFx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzVGVtcGxhdGUobGFiZWwpXCI+e3tsYWJlbH19PC9uZy1jb250YWluZXI+XG5cdFx0XHRcdDxuZy10ZW1wbGF0ZSAqbmdJZj1cImlzVGVtcGxhdGUobGFiZWwpXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwibGFiZWxcIj48L25nLXRlbXBsYXRlPlxuXHRcdFx0PC9zcGFuPlxuXHRcdFx0PHN2Z1xuXHRcdFx0XHQqbmdJZj1cImlzRmluaXNoZWRcIlxuXHRcdFx0XHRmaWxsPVwiY3VycmVudENvbG9yXCJcblx0XHRcdFx0Y2RzSWNvbj1cImNoZWNrbWFyay0tZmlsbGVkXCJcblx0XHRcdFx0Y2xhc3M9XCJjZHMtLXByb2dyZXNzLWJhcl9fc3RhdHVzLWljb25cIj5cblx0XHRcdDwvc3ZnPlxuXHRcdFx0PHN2Z1xuXHRcdFx0XHQqbmdJZj1cImlzRXJyb3JcIlxuXHRcdFx0XHRmaWxsPVwiY3VycmVudENvbG9yXCJcblx0XHRcdFx0Y2RzSWNvbj1cImVycm9yLS1maWxsZWRcIlxuXHRcdFx0XHRjbGFzcz1cImNkcy0tcHJvZ3Jlc3MtYmFyX19zdGF0dXMtaWNvblwiPlxuXHRcdFx0PC9zdmc+XG5cdFx0PC9kaXY+XG5cdFx0PGRpdlxuXHRcdFx0Y2xhc3M9XCJjZHMtLXByb2dyZXNzLWJhcl9fdHJhY2tcIlxuXHRcdFx0cm9sZT1cInByb2dyZXNzYmFyXCJcblx0XHRcdFthdHRyLmFyaWEtaW52YWxpZF09XCJpc0Vycm9yXCJcblx0XHRcdFthdHRyLmxhYmVsbGVkYnldPVwiaWRcIlxuXHRcdFx0W2F0dHIuZGVzY3JpYmVkYnldPVwiaGVscGVyVGV4dCA/IGhlbHBlcklkOiBudWxsXCJcblx0XHRcdFthdHRyLmFyaWEtdmFsdWVtaW5dPVwiIWluZGV0ZXJtaW5hdGUgPyAwIDogbnVsbFwiXG5cdFx0XHRbYXR0ci5hcmlhLXZhbHVlbWF4XT1cIiFpbmRldGVybWluYXRlID8gbWF4IDogbnVsbFwiXG5cdFx0XHRbYXR0ci5hcmlhLXZhbHVlbm93XT1cIiFpbmRldGVybWluYXRlID8gdmFsdWUgOiBudWxsXCI+XG5cdFx0XHQ8ZGl2XG5cdFx0XHRcdGNsYXNzPVwiY2RzLS1wcm9ncmVzcy1iYXJfX2JhclwiXG5cdFx0XHRcdFtuZ1N0eWxlXT1cIntcblx0XHRcdFx0XHQndHJhbnNmb3JtJzogIWlzRmluaXNoZWQgJiYgIWlzRXJyb3IgPyBwZXJjZW50YWdlIDogbnVsbFxuXHRcdFx0XHR9XCI+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblx0XHQ8ZGl2XG5cdFx0XHRbaWRdPVwiaGVscGVySWRcIlxuXHRcdFx0Km5nSWY9XCJoZWxwZXJUZXh0XCJcblx0XHRcdGNsYXNzPVwiY2RzLS1wcm9ncmVzcy1iYXJfX2hlbHBlci10ZXh0XCI+XG5cdFx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzVGVtcGxhdGUoaGVscGVyVGV4dClcIj57e2hlbHBlclRleHR9fTwvbmctY29udGFpbmVyPlxuXHRcdFx0PG5nLXRlbXBsYXRlICpuZ0lmPVwiaXNUZW1wbGF0ZShoZWxwZXJUZXh0KVwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImhlbHBlclRleHRcIj48L25nLXRlbXBsYXRlPlxuXHRcdDwvZGl2PlxuXHRgXG59KVxuZXhwb3J0IGNsYXNzIFByb2dyZXNzQmFyIHtcblx0LyoqXG5cdCAqIEN1cnJlbnQgdmFsdWVcblx0ICovXG5cdEBJbnB1dCgpIHNldCB2YWx1ZShudW06IG51bWJlciB8IHVuZGVmaW5lZCkge1xuXHRcdHRoaXMuX3ZhbHVlID0gbnVtO1xuXHRcdC8vIFZhbGlkYXRlIG51bWJlclxuXHRcdGlmIChudW0gPiB0aGlzLm1heCkge1xuXHRcdFx0dGhpcy5fdmFsdWUgPSB0aGlzLm1heDtcblx0XHR9XG5cdFx0aWYgKG51bSA8IDApIHtcblx0XHRcdHRoaXMuX3ZhbHVlID0gMDtcblx0XHR9XG5cdFx0Ly8gU2V0IHZhbHVlcyBiYXNlZCBvbiBjdXJyZW50IHN0YXRlXG5cdFx0aWYgKHRoaXMuaXNFcnJvcikge1xuXHRcdFx0dGhpcy5fdmFsdWUgPSAwO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5pc0ZpbmlzaGVkKSB7XG5cdFx0XHR0aGlzLl92YWx1ZSA9IHRoaXMubWF4O1xuXHRcdH1cblx0fVxuXG5cdGdldCB2YWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmFsdWU7XG5cdH1cblxuXHRnZXQgcGVyY2VudGFnZSgpIHtcblx0XHRyZXR1cm4gYHNjYWxlWCgke3RoaXMudmFsdWUgLyB0aGlzLm1heH0pYDtcblx0fVxuXHQvLyBTaXplXG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmNkcy0tcHJvZ3Jlc3MtYmFyLS1iaWdcIikgZ2V0IGJpZ0JhcigpIHtcblx0XHRyZXR1cm4gdGhpcy5zaXplID09PSBcImJpZ1wiO1xuXHR9XG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmNkcy0tcHJvZ3Jlc3MtYmFyLS1zbWFsbFwiKSBnZXQgc21hbGxCYXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2l6ZSA9PT0gXCJzbWFsbFwiO1xuXHR9XG5cdC8vIFR5cGVcblx0QEhvc3RCaW5kaW5nKFwiY2xhc3MuY2RzLS1wcm9ncmVzcy1iYXItLWRlZmF1bHRcIikgZ2V0IGRlZmF1bHRUeXBlKCkge1xuXHRcdHJldHVybiB0aGlzLnR5cGUgPT09IFwiZGVmYXVsdFwiO1xuXHR9XG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmNkcy0tcHJvZ3Jlc3MtYmFyLS1pbmRlbnRlZFwiKSBnZXQgaW5kZW50ZWRUeXBlKCkge1xuXHRcdHJldHVybiB0aGlzLnR5cGUgPT09IFwiaW5kZW50ZWRcIjtcblx0fVxuXHRASG9zdEJpbmRpbmcoXCJjbGFzcy5jZHMtLXByb2dyZXNzLWJhci0taW5saW5lXCIpIGdldCBpbmxpbmVUeXBlKCkge1xuXHRcdHJldHVybiB0aGlzLnR5cGUgPT09IFwiaW5saW5lXCI7XG5cdH1cblx0Ly8gU3RhdHVzXG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmNkcy0tcHJvZ3Jlc3MtYmFyLS1maW5pc2hlZFwiKSBnZXQgaXNGaW5pc2hlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5zdGF0dXMgPT09IFwiZmluaXNoZWRcIjtcblx0fVxuXHRASG9zdEJpbmRpbmcoXCJjbGFzcy5jZHMtLXByb2dyZXNzLWJhci0tZXJyb3JcIikgZ2V0IGlzRXJyb3IoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RhdHVzID09PSBcImVycm9yXCI7XG5cdH1cblx0QEhvc3RCaW5kaW5nKFwiY2xhc3MuY2RzLS1wcm9ncmVzcy1iYXItLWluZGV0ZXJtaW5hdGVcIikgZ2V0IGluZGV0ZXJtaW5hdGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhdGhpcy5pc0ZpbmlzaGVkICYmICF0aGlzLmlzRXJyb3I7XG5cdH1cblx0c3RhdGljIHByb2dyZXNzQmFyQ291bnRlciA9IDA7XG5cblx0QElucHV0KCkgaWQgPSBgcHJvZ3Jlc3MtYmFyLSR7UHJvZ3Jlc3NCYXIucHJvZ3Jlc3NCYXJDb3VudGVyKyt9YDtcblx0aGVscGVySWQgPSBgcHJvZ3Jlc3MtYmFyLWhlbHBlci0ke1Byb2dyZXNzQmFyLnByb2dyZXNzQmFyQ291bnRlcn1gO1xuXHQvKipcblx0ICogRGVzY3JpcHRpb24gb2YgdGhlIHByb2dyZXNzIGJhclxuXHQgKi9cblx0QElucHV0KCkgbGFiZWw6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cdC8qKlxuXHQgKiBDdXJyZW50IHByb2dyZXNzIHRleHR1YWwgcmVwcmVzZW50YXRpb25cblx0ICovXG5cdEBJbnB1dCgpIGhlbHBlclRleHQ6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cdC8qKlxuXHQgKiBNYXhpbXVtIHZhbHVlXG5cdCAqL1xuXHRASW5wdXQoKSBtYXggPSAxMDA7XG5cdC8qKlxuXHQgKiBBbGlnbm1lbnQgdmFyaWFudCBvZiB0aGUgcHJvZ3Jlc3MgYmFyLCBkZWZhdWx0IGlzIGBkZWZhdWx0YFxuXHQgKi9cblx0QElucHV0KCkgdHlwZTogXCJkZWZhdWx0XCIgfCBcImlubGluZVwiIHwgXCJpbmRlbnRlZFwiID0gXCJkZWZhdWx0XCI7XG5cdC8qKlxuXHQgKiBDdXJyZW50IHN0YXR1cyBvZiB0aGUgcHJvZ3Jlc3MgYmFyLCBkZWZhdWx0IGlzIGBhY3RpdmVgXG5cdCAqL1xuXHRASW5wdXQoKSBzdGF0dXM6IFwiYWN0aXZlXCIgfCBcImZpbmlzaGVkXCIgfCBcImVycm9yXCIgPSBcImFjdGl2ZVwiO1xuXHQvKipcblx0ICogU2l6ZSBvZiB0aGUgcHJvZ3Jlc3MgYmFyLCBkZWZhdWx0IGlzIGBiaWdgXG5cdCAqL1xuXHRASW5wdXQoKSBzaXplOiBcInNtYWxsXCIgfCBcImJpZ1wiID0gXCJiaWdcIjtcblxuXHRASG9zdEJpbmRpbmcoXCJjbGFzcy5jZHMtLXByb2dyZXNzLWJhclwiKSBkZWZhdWx0Q2xhc3MgPSB0cnVlO1xuXHRwcml2YXRlIF92YWx1ZSA9IHVuZGVmaW5lZDtcblxuXHRpc1RlbXBsYXRlKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVGVtcGxhdGVSZWY7XG5cdH1cbn1cbiJdfQ==