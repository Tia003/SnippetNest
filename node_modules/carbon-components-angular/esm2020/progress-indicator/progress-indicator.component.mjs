import { Component, Input, Output, EventEmitter } from "@angular/core";
import * as i0 from "@angular/core";
import * as i1 from "carbon-components-angular/i18n";
import * as i2 from "@angular/common";
import * as i3 from "carbon-components-angular/icon";
/**
 * Get started with importing the module:
 *
 * ```typescript
 * import { ProgressIndictorModule } from 'carbon-components-angular';
 * ```
 *
 * [See demo](../../?path=/story/components-progress-indicator--basic)
 */
export class ProgressIndicator {
    constructor(i18n) {
        this.i18n = i18n;
        this.stepSelected = new EventEmitter();
        this.translations = this.i18n.get().PROGRESS_INDICATOR;
        this.orientation = "horizontal";
        this.skeleton = false;
        this.spacing = "default";
        // Get icon names based for each status
        this.statusIcons = {
            current: "incomplete",
            complete: "checkmark--outline",
            invalid: "warning",
            incomplete: "circle-dash"
        };
    }
    get current() {
        return this._current;
    }
    set current(current) {
        this._current = current;
        this.setProgressIndicatorStates();
    }
    static skeletonSteps(stepCount) {
        const steps = [];
        for (let i = 0; i < stepCount; i++) {
            steps.push({ complete: false });
        }
        return steps;
    }
    /**
     * Executes click function if `onClick` exists for step
     * `Current` step functions will not be executed
     * @param index number
     */
    onClick(index) {
        if (index !== this.current && typeof this.steps[index].onClick === "function") {
            this.steps[index].onClick();
        }
        this.stepSelected.emit({ step: this.steps[index], index });
    }
    /**
     * Gets current state based on weight of the state
     * Weight of state goes from error, incomplete, current, and complete
     *
     * This function is used to determine which icon & translation string to display
     * @param index number
     * @returns string
     */
    getCurrentState(index) {
        if (index === this.current) {
            return "current";
        }
        else if (this.steps[index].invalid) {
            return "invalid";
        }
        else if (this.steps[index].complete) {
            return "complete";
        }
        return "incomplete";
    }
    setProgressIndicatorStates() {
        if (this.steps === undefined) {
            return;
        }
        // Set all preceding steps to `complete` & following to `incomplete`
        this.steps.forEach((step, index) => {
            if (index < this.current) {
                step.complete = true;
            }
            else {
                step.complete = false;
            }
        });
    }
}
ProgressIndicator.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ProgressIndicator, deps: [{ token: i1.I18n }], target: i0.ɵɵFactoryTarget.Component });
ProgressIndicator.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: ProgressIndicator, selector: "cds-progress-indicator, ibm-progress-indicator", inputs: { current: "current", steps: "steps", translations: "translations", orientation: "orientation", skeleton: "skeleton", spacing: "spacing" }, outputs: { stepSelected: "stepSelected" }, ngImport: i0, template: `
	<ul
		data-progress
		data-progress-current
		class="cds--progress"
		[ngClass]="{
			'cds--skeleton': skeleton,
			'cds--progress--vertical': (orientation === 'vertical'),
			'cds--progress--space-equal': spacing === 'equal' && orientation !== 'vertical'
		}">
		<li
			class="cds--progress-step"
			*ngFor="let step of steps; let i = index"
			[ngClass]="{
				'cds--progress-step--disabled' : step.disabled,
				'cds--progress-step--complete' : step.complete,
				'cds--progress-step--incomplete' : !step.complete && i !== current,
				'cds--progress-step--current': i === current
			}">
			<button
				type="button"
				class="cds--progress-step-button"
				[ngClass]="{
					'cds--progress-step-button--unclickable': !step.onClick || current === i
				}"
				[disabled]="step.disabled"
				[attr.aria-disabled]="step.disabled"
				[tabindex]="(current !== i && step.onClick && !step.disabled) ? 0 : -1"
				[title]="step.label"
				(click)="onClick(i)">
				<span class="cds--assistive-text">
					{{this.translations[getCurrentState(i)?.toUpperCase()]}}
				</span>
				<svg
					[cdsIcon]="statusIcons[getCurrentState(i)]"
					size="16"
					[ngClass]="{
						'cds--progress__warning': step.invalid && i !== current
					}">
					<title *ngIf="step.description">{{step.description}}</title>
				</svg>
				<div class="cds--progress-text">
					<p class="cds--progress-label">{{step.label}}</p>
					<p *ngIf="step.secondaryLabel" class="cds--progress-optional">{{step.secondaryLabel}}</p>
				</div>
				<span class="cds--progress-line"></span>
			</button>
		</li>
	</ul>
	`, isInline: true, dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.IconDirective, selector: "[cdsIcon], [ibmIcon]", inputs: ["ibmIcon", "cdsIcon", "size", "title", "ariaLabel", "ariaLabelledBy", "ariaHidden", "isFocusable"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ProgressIndicator, decorators: [{
            type: Component,
            args: [{
                    selector: "cds-progress-indicator, ibm-progress-indicator",
                    template: `
	<ul
		data-progress
		data-progress-current
		class="cds--progress"
		[ngClass]="{
			'cds--skeleton': skeleton,
			'cds--progress--vertical': (orientation === 'vertical'),
			'cds--progress--space-equal': spacing === 'equal' && orientation !== 'vertical'
		}">
		<li
			class="cds--progress-step"
			*ngFor="let step of steps; let i = index"
			[ngClass]="{
				'cds--progress-step--disabled' : step.disabled,
				'cds--progress-step--complete' : step.complete,
				'cds--progress-step--incomplete' : !step.complete && i !== current,
				'cds--progress-step--current': i === current
			}">
			<button
				type="button"
				class="cds--progress-step-button"
				[ngClass]="{
					'cds--progress-step-button--unclickable': !step.onClick || current === i
				}"
				[disabled]="step.disabled"
				[attr.aria-disabled]="step.disabled"
				[tabindex]="(current !== i && step.onClick && !step.disabled) ? 0 : -1"
				[title]="step.label"
				(click)="onClick(i)">
				<span class="cds--assistive-text">
					{{this.translations[getCurrentState(i)?.toUpperCase()]}}
				</span>
				<svg
					[cdsIcon]="statusIcons[getCurrentState(i)]"
					size="16"
					[ngClass]="{
						'cds--progress__warning': step.invalid && i !== current
					}">
					<title *ngIf="step.description">{{step.description}}</title>
				</svg>
				<div class="cds--progress-text">
					<p class="cds--progress-label">{{step.label}}</p>
					<p *ngIf="step.secondaryLabel" class="cds--progress-optional">{{step.secondaryLabel}}</p>
				</div>
				<span class="cds--progress-line"></span>
			</button>
		</li>
	</ul>
	`
                }]
        }], ctorParameters: function () { return [{ type: i1.I18n }]; }, propDecorators: { current: [{
                type: Input
            }], steps: [{
                type: Input
            }], stepSelected: [{
                type: Output
            }], translations: [{
                type: Input
            }], orientation: [{
                type: Input
            }], skeleton: [{
                type: Input
            }], spacing: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3MtaW5kaWNhdG9yLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wcm9ncmVzcy1pbmRpY2F0b3IvcHJvZ3Jlc3MtaW5kaWNhdG9yLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLE1BQU0sZUFBZSxDQUFDOzs7OztBQUl2Qjs7Ozs7Ozs7R0FRRztBQXNESCxNQUFNLE9BQU8saUJBQWlCO0lBbUM3QixZQUFzQixJQUFVO1FBQVYsU0FBSSxHQUFKLElBQUksQ0FBTTtRQWpCdEIsaUJBQVksR0FBRyxJQUFJLFlBQVksRUFBaUMsQ0FBQztRQUVsRSxpQkFBWSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUM7UUFDbEQsZ0JBQVcsR0FBOEIsWUFBWSxDQUFDO1FBQ3RELGFBQVEsR0FBRyxLQUFLLENBQUM7UUFDakIsWUFBTyxHQUF3QixTQUFTLENBQUM7UUFFbEQsdUNBQXVDO1FBQzlCLGdCQUFXLEdBQUc7WUFDdEIsT0FBTyxFQUFFLFlBQVk7WUFDckIsUUFBUSxFQUFFLG9CQUFvQjtZQUM5QixPQUFPLEVBQUUsU0FBUztZQUNsQixVQUFVLEVBQUUsYUFBYTtTQUN6QixDQUFDO0lBSWtDLENBQUM7SUFsQ3JDLElBQWEsT0FBTztRQUNuQixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDdEIsQ0FBQztJQUNELElBQUksT0FBTyxDQUFDLE9BQWU7UUFDMUIsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUM7UUFDeEIsSUFBSSxDQUFDLDBCQUEwQixFQUFFLENBQUM7SUFDbkMsQ0FBQztJQUNELE1BQU0sQ0FBQyxhQUFhLENBQUMsU0FBaUI7UUFDckMsTUFBTSxLQUFLLEdBQUcsRUFBRSxDQUFDO1FBQ2pCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDbkMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBQ2hDO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZCxDQUFDO0lBc0JEOzs7O09BSUc7SUFDSCxPQUFPLENBQUMsS0FBYTtRQUNwQixJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsT0FBTyxJQUFJLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLEtBQUssVUFBVSxFQUFFO1lBQzlFLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7U0FDNUI7UUFDRCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxlQUFlLENBQUMsS0FBYTtRQUM1QixJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQzNCLE9BQU8sU0FBUyxDQUFDO1NBQ2pCO2FBQU0sSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sRUFBRTtZQUNyQyxPQUFPLFNBQVMsQ0FBQztTQUNqQjthQUFNLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUU7WUFDdEMsT0FBTyxVQUFVLENBQUM7U0FDbEI7UUFFRCxPQUFPLFlBQVksQ0FBQztJQUNyQixDQUFDO0lBRU8sMEJBQTBCO1FBQ2pDLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxTQUFTLEVBQUU7WUFDN0IsT0FBTztTQUNQO1FBRUQsb0VBQW9FO1FBQ3BFLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBVSxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQ3hDLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO2FBQ3JCO2lCQUFNO2dCQUNOLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO2FBQ3RCO1FBQ0YsQ0FBQyxDQUFDLENBQUM7SUFDSixDQUFDOzs4R0FsRlcsaUJBQWlCO2tHQUFqQixpQkFBaUIscVJBbkRuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQWlEVDsyRkFFVyxpQkFBaUI7a0JBckQ3QixTQUFTO21CQUFDO29CQUNWLFFBQVEsRUFBRSxnREFBZ0Q7b0JBQzFELFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQWlEVDtpQkFDRDsyRkFFYSxPQUFPO3NCQUFuQixLQUFLO2dCQWdCRyxLQUFLO3NCQUFiLEtBQUs7Z0JBQ0ksWUFBWTtzQkFBckIsTUFBTTtnQkFFRSxZQUFZO3NCQUFwQixLQUFLO2dCQUNHLFdBQVc7c0JBQW5CLEtBQUs7Z0JBQ0csUUFBUTtzQkFBaEIsS0FBSztnQkFDRyxPQUFPO3NCQUFmLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRDb21wb25lbnQsXG5cdElucHV0LFxuXHRPdXRwdXQsXG5cdEV2ZW50RW1pdHRlclxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgSTE4biB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2kxOG5cIjtcbmltcG9ydCB7IFN0ZXAgfSBmcm9tIFwiLi9wcm9ncmVzcy1pbmRpY2F0b3Itc3RlcC5pbnRlcmZhY2VcIjtcblxuLyoqXG4gKiBHZXQgc3RhcnRlZCB3aXRoIGltcG9ydGluZyB0aGUgbW9kdWxlOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IFByb2dyZXNzSW5kaWN0b3JNb2R1bGUgfSBmcm9tICdjYXJib24tY29tcG9uZW50cy1hbmd1bGFyJztcbiAqIGBgYFxuICpcbiAqIFtTZWUgZGVtb10oLi4vLi4vP3BhdGg9L3N0b3J5L2NvbXBvbmVudHMtcHJvZ3Jlc3MtaW5kaWNhdG9yLS1iYXNpYylcbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiBcImNkcy1wcm9ncmVzcy1pbmRpY2F0b3IsIGlibS1wcm9ncmVzcy1pbmRpY2F0b3JcIixcblx0dGVtcGxhdGU6IGBcblx0PHVsXG5cdFx0ZGF0YS1wcm9ncmVzc1xuXHRcdGRhdGEtcHJvZ3Jlc3MtY3VycmVudFxuXHRcdGNsYXNzPVwiY2RzLS1wcm9ncmVzc1wiXG5cdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0J2Nkcy0tc2tlbGV0b24nOiBza2VsZXRvbixcblx0XHRcdCdjZHMtLXByb2dyZXNzLS12ZXJ0aWNhbCc6IChvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyksXG5cdFx0XHQnY2RzLS1wcm9ncmVzcy0tc3BhY2UtZXF1YWwnOiBzcGFjaW5nID09PSAnZXF1YWwnICYmIG9yaWVudGF0aW9uICE9PSAndmVydGljYWwnXG5cdFx0fVwiPlxuXHRcdDxsaVxuXHRcdFx0Y2xhc3M9XCJjZHMtLXByb2dyZXNzLXN0ZXBcIlxuXHRcdFx0Km5nRm9yPVwibGV0IHN0ZXAgb2Ygc3RlcHM7IGxldCBpID0gaW5kZXhcIlxuXHRcdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0XHQnY2RzLS1wcm9ncmVzcy1zdGVwLS1kaXNhYmxlZCcgOiBzdGVwLmRpc2FibGVkLFxuXHRcdFx0XHQnY2RzLS1wcm9ncmVzcy1zdGVwLS1jb21wbGV0ZScgOiBzdGVwLmNvbXBsZXRlLFxuXHRcdFx0XHQnY2RzLS1wcm9ncmVzcy1zdGVwLS1pbmNvbXBsZXRlJyA6ICFzdGVwLmNvbXBsZXRlICYmIGkgIT09IGN1cnJlbnQsXG5cdFx0XHRcdCdjZHMtLXByb2dyZXNzLXN0ZXAtLWN1cnJlbnQnOiBpID09PSBjdXJyZW50XG5cdFx0XHR9XCI+XG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdHR5cGU9XCJidXR0b25cIlxuXHRcdFx0XHRjbGFzcz1cImNkcy0tcHJvZ3Jlc3Mtc3RlcC1idXR0b25cIlxuXHRcdFx0XHRbbmdDbGFzc109XCJ7XG5cdFx0XHRcdFx0J2Nkcy0tcHJvZ3Jlc3Mtc3RlcC1idXR0b24tLXVuY2xpY2thYmxlJzogIXN0ZXAub25DbGljayB8fCBjdXJyZW50ID09PSBpXG5cdFx0XHRcdH1cIlxuXHRcdFx0XHRbZGlzYWJsZWRdPVwic3RlcC5kaXNhYmxlZFwiXG5cdFx0XHRcdFthdHRyLmFyaWEtZGlzYWJsZWRdPVwic3RlcC5kaXNhYmxlZFwiXG5cdFx0XHRcdFt0YWJpbmRleF09XCIoY3VycmVudCAhPT0gaSAmJiBzdGVwLm9uQ2xpY2sgJiYgIXN0ZXAuZGlzYWJsZWQpID8gMCA6IC0xXCJcblx0XHRcdFx0W3RpdGxlXT1cInN0ZXAubGFiZWxcIlxuXHRcdFx0XHQoY2xpY2spPVwib25DbGljayhpKVwiPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImNkcy0tYXNzaXN0aXZlLXRleHRcIj5cblx0XHRcdFx0XHR7e3RoaXMudHJhbnNsYXRpb25zW2dldEN1cnJlbnRTdGF0ZShpKT8udG9VcHBlckNhc2UoKV19fVxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDxzdmdcblx0XHRcdFx0XHRbY2RzSWNvbl09XCJzdGF0dXNJY29uc1tnZXRDdXJyZW50U3RhdGUoaSldXCJcblx0XHRcdFx0XHRzaXplPVwiMTZcIlxuXHRcdFx0XHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdFx0XHRcdCdjZHMtLXByb2dyZXNzX193YXJuaW5nJzogc3RlcC5pbnZhbGlkICYmIGkgIT09IGN1cnJlbnRcblx0XHRcdFx0XHR9XCI+XG5cdFx0XHRcdFx0PHRpdGxlICpuZ0lmPVwic3RlcC5kZXNjcmlwdGlvblwiPnt7c3RlcC5kZXNjcmlwdGlvbn19PC90aXRsZT5cblx0XHRcdFx0PC9zdmc+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJjZHMtLXByb2dyZXNzLXRleHRcIj5cblx0XHRcdFx0XHQ8cCBjbGFzcz1cImNkcy0tcHJvZ3Jlc3MtbGFiZWxcIj57e3N0ZXAubGFiZWx9fTwvcD5cblx0XHRcdFx0XHQ8cCAqbmdJZj1cInN0ZXAuc2Vjb25kYXJ5TGFiZWxcIiBjbGFzcz1cImNkcy0tcHJvZ3Jlc3Mtb3B0aW9uYWxcIj57e3N0ZXAuc2Vjb25kYXJ5TGFiZWx9fTwvcD5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiY2RzLS1wcm9ncmVzcy1saW5lXCI+PC9zcGFuPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0PC9saT5cblx0PC91bD5cblx0YFxufSlcbmV4cG9ydCBjbGFzcyBQcm9ncmVzc0luZGljYXRvciB7XG5cdEBJbnB1dCgpIGdldCBjdXJyZW50KCkge1xuXHRcdHJldHVybiB0aGlzLl9jdXJyZW50O1xuXHR9XG5cdHNldCBjdXJyZW50KGN1cnJlbnQ6IG51bWJlcikge1xuXHRcdHRoaXMuX2N1cnJlbnQgPSBjdXJyZW50O1xuXHRcdHRoaXMuc2V0UHJvZ3Jlc3NJbmRpY2F0b3JTdGF0ZXMoKTtcblx0fVxuXHRzdGF0aWMgc2tlbGV0b25TdGVwcyhzdGVwQ291bnQ6IG51bWJlcikge1xuXHRcdGNvbnN0IHN0ZXBzID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdGVwQ291bnQ7IGkrKykge1xuXHRcdFx0c3RlcHMucHVzaCh7IGNvbXBsZXRlOiBmYWxzZSB9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3RlcHM7XG5cdH1cblxuXHRASW5wdXQoKSBzdGVwczogQXJyYXk8U3RlcD47XG5cdEBPdXRwdXQoKSBzdGVwU2VsZWN0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyPHsgc3RlcDogU3RlcCwgaW5kZXg6IG51bWJlciB9PigpO1xuXG5cdEBJbnB1dCgpIHRyYW5zbGF0aW9ucyA9IHRoaXMuaTE4bi5nZXQoKS5QUk9HUkVTU19JTkRJQ0FUT1I7XG5cdEBJbnB1dCgpIG9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcIiA9IFwiaG9yaXpvbnRhbFwiO1xuXHRASW5wdXQoKSBza2VsZXRvbiA9IGZhbHNlO1xuXHRASW5wdXQoKSBzcGFjaW5nOiBcImRlZmF1bHRcIiB8IFwiZXF1YWxcIiA9IFwiZGVmYXVsdFwiO1xuXG5cdC8vIEdldCBpY29uIG5hbWVzIGJhc2VkIGZvciBlYWNoIHN0YXR1c1xuXHRyZWFkb25seSBzdGF0dXNJY29ucyA9IHtcblx0XHRjdXJyZW50OiBcImluY29tcGxldGVcIixcblx0XHRjb21wbGV0ZTogXCJjaGVja21hcmstLW91dGxpbmVcIixcblx0XHRpbnZhbGlkOiBcIndhcm5pbmdcIixcblx0XHRpbmNvbXBsZXRlOiBcImNpcmNsZS1kYXNoXCJcblx0fTtcblxuXHRwcml2YXRlIF9jdXJyZW50OiBudW1iZXI7XG5cblx0Y29uc3RydWN0b3IocHJvdGVjdGVkIGkxOG46IEkxOG4pIHsgfVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlcyBjbGljayBmdW5jdGlvbiBpZiBgb25DbGlja2AgZXhpc3RzIGZvciBzdGVwXG5cdCAqIGBDdXJyZW50YCBzdGVwIGZ1bmN0aW9ucyB3aWxsIG5vdCBiZSBleGVjdXRlZFxuXHQgKiBAcGFyYW0gaW5kZXggbnVtYmVyXG5cdCAqL1xuXHRvbkNsaWNrKGluZGV4OiBudW1iZXIpIHtcblx0XHRpZiAoaW5kZXggIT09IHRoaXMuY3VycmVudCAmJiB0eXBlb2YgdGhpcy5zdGVwc1tpbmRleF0ub25DbGljayA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR0aGlzLnN0ZXBzW2luZGV4XS5vbkNsaWNrKCk7XG5cdFx0fVxuXHRcdHRoaXMuc3RlcFNlbGVjdGVkLmVtaXQoeyBzdGVwOiB0aGlzLnN0ZXBzW2luZGV4XSwgaW5kZXggfSk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBjdXJyZW50IHN0YXRlIGJhc2VkIG9uIHdlaWdodCBvZiB0aGUgc3RhdGVcblx0ICogV2VpZ2h0IG9mIHN0YXRlIGdvZXMgZnJvbSBlcnJvciwgaW5jb21wbGV0ZSwgY3VycmVudCwgYW5kIGNvbXBsZXRlXG5cdCAqXG5cdCAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggaWNvbiAmIHRyYW5zbGF0aW9uIHN0cmluZyB0byBkaXNwbGF5XG5cdCAqIEBwYXJhbSBpbmRleCBudW1iZXJcblx0ICogQHJldHVybnMgc3RyaW5nXG5cdCAqL1xuXHRnZXRDdXJyZW50U3RhdGUoaW5kZXg6IG51bWJlcikge1xuXHRcdGlmIChpbmRleCA9PT0gdGhpcy5jdXJyZW50KSB7XG5cdFx0XHRyZXR1cm4gXCJjdXJyZW50XCI7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnN0ZXBzW2luZGV4XS5pbnZhbGlkKSB7XG5cdFx0XHRyZXR1cm4gXCJpbnZhbGlkXCI7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnN0ZXBzW2luZGV4XS5jb21wbGV0ZSkge1xuXHRcdFx0cmV0dXJuIFwiY29tcGxldGVcIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gXCJpbmNvbXBsZXRlXCI7XG5cdH1cblxuXHRwcml2YXRlIHNldFByb2dyZXNzSW5kaWNhdG9yU3RhdGVzKCkge1xuXHRcdGlmICh0aGlzLnN0ZXBzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBTZXQgYWxsIHByZWNlZGluZyBzdGVwcyB0byBgY29tcGxldGVgICYgZm9sbG93aW5nIHRvIGBpbmNvbXBsZXRlYFxuXHRcdHRoaXMuc3RlcHMuZm9yRWFjaCgoc3RlcDogU3RlcCwgaW5kZXgpID0+IHtcblx0XHRcdGlmIChpbmRleCA8IHRoaXMuY3VycmVudCkge1xuXHRcdFx0XHRzdGVwLmNvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0ZXAuY29tcGxldGUgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufVxuIl19