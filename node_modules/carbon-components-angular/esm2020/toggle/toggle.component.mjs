import { Checkbox } from "carbon-components-angular/checkbox";
import { Component, Input, HostBinding, TemplateRef } from "@angular/core";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
import * as i0 from "@angular/core";
import * as i1 from "carbon-components-angular/i18n";
import * as i2 from "@angular/common";
/**
 * Defines the set of states for a toggle component.
 */
export var ToggleState;
(function (ToggleState) {
    ToggleState[ToggleState["Init"] = 0] = "Init";
    ToggleState[ToggleState["Checked"] = 1] = "Checked";
    ToggleState[ToggleState["Unchecked"] = 2] = "Unchecked";
})(ToggleState || (ToggleState = {}));
/**
 * Get started with importing the module:
 *
 * ```typescript
 * import { ToggleModule } from 'carbon-components-angular';
 * ```
 *
 * ```html
 * <cds-toggle [(ngModel)]="toggleState">Toggle</cds-toggle>
 * ```
 *
 * [See demo](../../?path=/story/components-toggle--basic)
 */
export class Toggle extends Checkbox {
    /**
     * Creates an instance of Toggle.
     */
    constructor(changeDetectorRef, i18n) {
        super(changeDetectorRef);
        this.changeDetectorRef = changeDetectorRef;
        this.i18n = i18n;
        /**
         * Size of the toggle component.
         */
        this.size = "md";
        /**
         * Set to `true` to hide the toggle label & set toggle on/off text to label.
         */
        this.hideLabel = false;
        this.skeleton = false;
        this.toggleClass = true;
        /**
         * The unique id allocated to the `Toggle`.
         */
        this.id = "toggle-" + Toggle.toggleCount;
        this._offValues = this.i18n.getOverridable("TOGGLE.OFF");
        this._onValues = this.i18n.getOverridable("TOGGLE.ON");
        Toggle.toggleCount++;
    }
    /**
     * Text that is set on the left side of the toggle.
     */
    set offText(value) {
        this._offValues.override(value);
    }
    get offText() {
        return this._offValues.value;
    }
    /**
     * Text that is set on the right side of the toggle.
     */
    set onText(value) {
        this._onValues.override(value);
    }
    get onText() {
        return this._onValues.value;
    }
    get disabledClass() {
        return this.disabled;
    }
    get formItem() {
        return !this.skeleton;
    }
    /**
     * `ControlValueAccessor` method to programmatically disable the toggle input.
     *
     * ex: `this.formGroup.get("myToggle").disable();`
     *
     * @param isDisabled `true` to disable the input
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    getOffText() {
        return this._offValues.subject;
    }
    getOnText() {
        return this._onValues.subject;
    }
    getCheckedText() {
        if (this.checked) {
            return this._onValues.subject;
        }
        return this._offValues.subject;
    }
    /**
     * Creates instance of `ToggleChange` used to propagate the change event.
     */
    emitChangeEvent() {
        this.checkedChange.emit(this.checked);
        this.propagateChange(this.checked);
    }
    isTemplate(value) {
        return value instanceof TemplateRef;
    }
}
/**
 * Variable used for creating unique ids for toggle components.
 */
Toggle.toggleCount = 0;
Toggle.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Toggle, deps: [{ token: i0.ChangeDetectorRef }, { token: i1.I18n }], target: i0.ɵɵFactoryTarget.Component });
Toggle.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: Toggle, selector: "cds-toggle, ibm-toggle", inputs: { offText: "offText", onText: "onText", label: "label", size: "size", hideLabel: "hideLabel", skeleton: "skeleton" }, host: { properties: { "class.cds--toggle--skeleton": "this.skeleton", "class.cds--toggle": "this.toggleClass", "class.cds--toggle--disabled": "this.disabledClass", "class.cds--form-item": "this.formItem" } }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: Toggle,
            multi: true
        }
    ], usesInheritance: true, ngImport: i0, template: `
		<ng-container *ngIf="!skeleton; else skeletonTemplate;">
			<button
				class="cds--toggle__button"
				[disabled]="disabled"
				[id]="id"
				role="switch"
				type="button"
				[attr.aria-checked]="checked"
				(click)="onClick($event)">
			</button>
			<label
				class="cds--toggle__label"
				[for]="id">
				<span
					class="cds--toggle__label-text"
					[ngClass]="{
						'cds--visually-hidden': hideLabel
					}">
					<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
					<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
				</span>
				<div
					class="cds--toggle__appearance"
					[ngClass]="{
						'cds--toggle__appearance--sm': size === 'sm'
					}">
					<div
						class="cds--toggle__switch"
						[ngClass]="{
							'cds--toggle__switch--checked': checked
						}">
						<svg
							*ngIf="size === 'sm'"
							class='cds--toggle__check'
							width="6px"
							height="5px"
							viewBox="0 0 6 5">
							<path d="M2.2 2.7L5 0 6 1 2.2 5 0 2.7 1 1.5z" />
						</svg>
					</div>
					<span class="cds--toggle__text">
						{{(hideLabel ? label : (getCheckedText() | async))}}
					</span>
				</div>
			</label>
		</ng-container>
		<ng-template #skeletonTemplate>
			<div class="cds--toggle__skeleton-circle"></div>
			<div class="cds--toggle__skeleton-rectangle"></div>
		</ng-template>
	`, isInline: true, dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "pipe", type: i2.AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Toggle, decorators: [{
            type: Component,
            args: [{
                    selector: "cds-toggle, ibm-toggle",
                    template: `
		<ng-container *ngIf="!skeleton; else skeletonTemplate;">
			<button
				class="cds--toggle__button"
				[disabled]="disabled"
				[id]="id"
				role="switch"
				type="button"
				[attr.aria-checked]="checked"
				(click)="onClick($event)">
			</button>
			<label
				class="cds--toggle__label"
				[for]="id">
				<span
					class="cds--toggle__label-text"
					[ngClass]="{
						'cds--visually-hidden': hideLabel
					}">
					<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
					<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
				</span>
				<div
					class="cds--toggle__appearance"
					[ngClass]="{
						'cds--toggle__appearance--sm': size === 'sm'
					}">
					<div
						class="cds--toggle__switch"
						[ngClass]="{
							'cds--toggle__switch--checked': checked
						}">
						<svg
							*ngIf="size === 'sm'"
							class='cds--toggle__check'
							width="6px"
							height="5px"
							viewBox="0 0 6 5">
							<path d="M2.2 2.7L5 0 6 1 2.2 5 0 2.7 1 1.5z" />
						</svg>
					</div>
					<span class="cds--toggle__text">
						{{(hideLabel ? label : (getCheckedText() | async))}}
					</span>
				</div>
			</label>
		</ng-container>
		<ng-template #skeletonTemplate>
			<div class="cds--toggle__skeleton-circle"></div>
			<div class="cds--toggle__skeleton-rectangle"></div>
		</ng-template>
	`,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: Toggle,
                            multi: true
                        }
                    ]
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i1.I18n }]; }, propDecorators: { offText: [{
                type: Input
            }], onText: [{
                type: Input
            }], label: [{
                type: Input
            }], size: [{
                type: Input
            }], hideLabel: [{
                type: Input
            }], skeleton: [{
                type: HostBinding,
                args: ["class.cds--toggle--skeleton"]
            }, {
                type: Input
            }], toggleClass: [{
                type: HostBinding,
                args: ["class.cds--toggle"]
            }], disabledClass: [{
                type: HostBinding,
                args: ["class.cds--toggle--disabled"]
            }], formItem: [{
                type: HostBinding,
                args: ["class.cds--form-item"]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9nZ2xlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90b2dnbGUvdG9nZ2xlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDOUQsT0FBTyxFQUVOLFNBQVMsRUFDVCxLQUFLLEVBQ0wsV0FBVyxFQUNYLFdBQVcsRUFDWCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7OztBQUtuRDs7R0FFRztBQUNILE1BQU0sQ0FBTixJQUFZLFdBSVg7QUFKRCxXQUFZLFdBQVc7SUFDdEIsNkNBQUksQ0FBQTtJQUNKLG1EQUFPLENBQUE7SUFDUCx1REFBUyxDQUFBO0FBQ1YsQ0FBQyxFQUpXLFdBQVcsS0FBWCxXQUFXLFFBSXRCO0FBRUQ7Ozs7Ozs7Ozs7OztHQVlHO0FBK0RILE1BQU0sT0FBTyxNQUFPLFNBQVEsUUFBUTtJQTREbkM7O09BRUc7SUFDSCxZQUFzQixpQkFBb0MsRUFBWSxJQUFVO1FBQy9FLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBREosc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQUFZLFNBQUksR0FBSixJQUFJLENBQU07UUE5QmhGOztXQUVHO1FBQ00sU0FBSSxHQUFnQixJQUFJLENBQUM7UUFDbEM7O1dBRUc7UUFDTSxjQUFTLEdBQUcsS0FBSyxDQUFDO1FBRTBCLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFFcEMsZ0JBQVcsR0FBRyxJQUFJLENBQUM7UUFTckQ7O1dBRUc7UUFDSCxPQUFFLEdBQUcsU0FBUyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUM7UUFFMUIsZUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ3BELGNBQVMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGNB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cnQgeyBDaGVja2JveCB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2NoZWNrYm94XCI7XG5pbXBvcnQge1xuXHRDaGFuZ2VEZXRlY3RvclJlZixcblx0Q29tcG9uZW50LFxuXHRJbnB1dCxcblx0SG9zdEJpbmRpbmcsXG5cdFRlbXBsYXRlUmVmXG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gXCJAYW5ndWxhci9mb3Jtc1wiO1xuXG5pbXBvcnQgeyBJMThuIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvaTE4blwiO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gXCJyeGpzXCI7XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgc2V0IG9mIHN0YXRlcyBmb3IgYSB0b2dnbGUgY29tcG9uZW50LlxuICovXG5leHBvcnQgZW51bSBUb2dnbGVTdGF0ZSB7XG5cdEluaXQsXG5cdENoZWNrZWQsXG5cdFVuY2hlY2tlZFxufVxuXG4vKipcbiAqIEdldCBzdGFydGVkIHdpdGggaW1wb3J0aW5nIHRoZSBtb2R1bGU6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgVG9nZ2xlTW9kdWxlIH0gZnJvbSAnY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhcic7XG4gKiBgYGBcbiAqXG4gKiBgYGBodG1sXG4gKiA8Y2RzLXRvZ2dsZSBbKG5nTW9kZWwpXT1cInRvZ2dsZVN0YXRlXCI+VG9nZ2xlPC9jZHMtdG9nZ2xlPlxuICogYGBgXG4gKlxuICogW1NlZSBkZW1vXSguLi8uLi8/cGF0aD0vc3RvcnkvY29tcG9uZW50cy10b2dnbGUtLWJhc2ljKVxuICovXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6IFwiY2RzLXRvZ2dsZSwgaWJtLXRvZ2dsZVwiLFxuXHR0ZW1wbGF0ZTogYFxuXHRcdDxuZy1jb250YWluZXIgKm5nSWY9XCIhc2tlbGV0b247IGVsc2Ugc2tlbGV0b25UZW1wbGF0ZTtcIj5cblx0XHRcdDxidXR0b25cblx0XHRcdFx0Y2xhc3M9XCJjZHMtLXRvZ2dsZV9fYnV0dG9uXCJcblx0XHRcdFx0W2Rpc2FibGVkXT1cImRpc2FibGVkXCJcblx0XHRcdFx0W2lkXT1cImlkXCJcblx0XHRcdFx0cm9sZT1cInN3aXRjaFwiXG5cdFx0XHRcdHR5cGU9XCJidXR0b25cIlxuXHRcdFx0XHRbYXR0ci5hcmlhLWNoZWNrZWRdPVwiY2hlY2tlZFwiXG5cdFx0XHRcdChjbGljayk9XCJvbkNsaWNrKCRldmVudClcIj5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0PGxhYmVsXG5cdFx0XHRcdGNsYXNzPVwiY2RzLS10b2dnbGVfX2xhYmVsXCJcblx0XHRcdFx0W2Zvcl09XCJpZFwiPlxuXHRcdFx0XHQ8c3BhblxuXHRcdFx0XHRcdGNsYXNzPVwiY2RzLS10b2dnbGVfX2xhYmVsLXRleHRcIlxuXHRcdFx0XHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdFx0XHRcdCdjZHMtLXZpc3VhbGx5LWhpZGRlbic6IGhpZGVMYWJlbFxuXHRcdFx0XHRcdH1cIj5cblx0XHRcdFx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzVGVtcGxhdGUobGFiZWwpXCI+e3tsYWJlbH19PC9uZy1jb250YWluZXI+XG5cdFx0XHRcdFx0PG5nLXRlbXBsYXRlICpuZ0lmPVwiaXNUZW1wbGF0ZShsYWJlbClcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJsYWJlbFwiPjwvbmctdGVtcGxhdGU+XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdGNsYXNzPVwiY2RzLS10b2dnbGVfX2FwcGVhcmFuY2VcIlxuXHRcdFx0XHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdFx0XHRcdCdjZHMtLXRvZ2dsZV9fYXBwZWFyYW5jZS0tc20nOiBzaXplID09PSAnc20nXG5cdFx0XHRcdFx0fVwiPlxuXHRcdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRcdGNsYXNzPVwiY2RzLS10b2dnbGVfX3N3aXRjaFwiXG5cdFx0XHRcdFx0XHRbbmdDbGFzc109XCJ7XG5cdFx0XHRcdFx0XHRcdCdjZHMtLXRvZ2dsZV9fc3dpdGNoLS1jaGVja2VkJzogY2hlY2tlZFxuXHRcdFx0XHRcdFx0fVwiPlxuXHRcdFx0XHRcdFx0PHN2Z1xuXHRcdFx0XHRcdFx0XHQqbmdJZj1cInNpemUgPT09ICdzbSdcIlxuXHRcdFx0XHRcdFx0XHRjbGFzcz0nY2RzLS10b2dnbGVfX2NoZWNrJ1xuXHRcdFx0XHRcdFx0XHR3aWR0aD1cIjZweFwiXG5cdFx0XHRcdFx0XHRcdGhlaWdodD1cIjVweFwiXG5cdFx0XHRcdFx0XHRcdHZpZXdCb3g9XCIwIDAgNiA1XCI+XG5cdFx0XHRcdFx0XHRcdDxwYXRoIGQ9XCJNMi4yIDIuN0w1IDAgNiAxIDIuMiA1IDAgMi43IDEgMS41elwiIC8+XG5cdFx0XHRcdFx0XHQ8L3N2Zz5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImNkcy0tdG9nZ2xlX190ZXh0XCI+XG5cdFx0XHRcdFx0XHR7eyhoaWRlTGFiZWwgPyBsYWJlbCA6IChnZXRDaGVja2VkVGV4dCgpIHwgYXN5bmMpKX19XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvbGFiZWw+XG5cdFx0PC9uZy1jb250YWluZXI+XG5cdFx0PG5nLXRlbXBsYXRlICNza2VsZXRvblRlbXBsYXRlPlxuXHRcdFx0PGRpdiBjbGFzcz1cImNkcy0tdG9nZ2xlX19za2VsZXRvbi1jaXJjbGVcIj48L2Rpdj5cblx0XHRcdDxkaXYgY2xhc3M9XCJjZHMtLXRvZ2dsZV9fc2tlbGV0b24tcmVjdGFuZ2xlXCI+PC9kaXY+XG5cdFx0PC9uZy10ZW1wbGF0ZT5cblx0YCxcblx0cHJvdmlkZXJzOiBbXG5cdFx0e1xuXHRcdFx0cHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG5cdFx0XHR1c2VFeGlzdGluZzogVG9nZ2xlLFxuXHRcdFx0bXVsdGk6IHRydWVcblx0XHR9XG5cdF1cbn0pXG5leHBvcnQgY2xhc3MgVG9nZ2xlIGV4dGVuZHMgQ2hlY2tib3gge1xuXHQvKipcblx0ICogVmFyaWFibGUgdXNlZCBmb3IgY3JlYXRpbmcgdW5pcXVlIGlkcyBmb3IgdG9nZ2xlIGNvbXBvbmVudHMuXG5cdCAqL1xuXHRzdGF0aWMgdG9nZ2xlQ291bnQgPSAwO1xuXG5cdC8qKlxuXHQgKiBUZXh0IHRoYXQgaXMgc2V0IG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHRvZ2dsZS5cblx0ICovXG5cdEBJbnB1dCgpXG5cdHNldCBvZmZUZXh0KHZhbHVlOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4pIHtcblx0XHR0aGlzLl9vZmZWYWx1ZXMub3ZlcnJpZGUodmFsdWUpO1xuXHR9XG5cblx0Z2V0IG9mZlRleHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX29mZlZhbHVlcy52YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUZXh0IHRoYXQgaXMgc2V0IG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSB0b2dnbGUuXG5cdCAqL1xuXHRASW5wdXQoKVxuXHRzZXQgb25UZXh0KHZhbHVlOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4pIHtcblx0XHR0aGlzLl9vblZhbHVlcy5vdmVycmlkZSh2YWx1ZSk7XG5cdH1cblxuXHRnZXQgb25UZXh0KCkge1xuXHRcdHJldHVybiB0aGlzLl9vblZhbHVlcy52YWx1ZTtcblx0fVxuXHQvKipcblx0ICogVGV4dCB0aGF0IGlzIHNldCBhcyB0aGUgbGFiZWwgb2YgdGhlIHRvZ2dsZS5cblx0ICovXG5cdEBJbnB1dCgpIGxhYmVsOiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+O1xuXHQvKipcblx0ICogU2l6ZSBvZiB0aGUgdG9nZ2xlIGNvbXBvbmVudC5cblx0ICovXG5cdEBJbnB1dCgpIHNpemU6IFwic21cIiB8IFwibWRcIiA9IFwibWRcIjtcblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgdG8gaGlkZSB0aGUgdG9nZ2xlIGxhYmVsICYgc2V0IHRvZ2dsZSBvbi9vZmYgdGV4dCB0byBsYWJlbC5cblx0ICovXG5cdEBJbnB1dCgpIGhpZGVMYWJlbCA9IGZhbHNlO1xuXG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmNkcy0tdG9nZ2xlLS1za2VsZXRvblwiKSBASW5wdXQoKSBza2VsZXRvbiA9IGZhbHNlO1xuXG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmNkcy0tdG9nZ2xlXCIpIHRvZ2dsZUNsYXNzID0gdHJ1ZTtcblx0QEhvc3RCaW5kaW5nKFwiY2xhc3MuY2RzLS10b2dnbGUtLWRpc2FibGVkXCIpIGdldCBkaXNhYmxlZENsYXNzICgpIHtcblx0XHRyZXR1cm4gdGhpcy5kaXNhYmxlZDtcblx0fVxuXG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmNkcy0tZm9ybS1pdGVtXCIpIGdldCBmb3JtSXRlbSgpIHtcblx0XHRyZXR1cm4gIXRoaXMuc2tlbGV0b247XG5cdH1cblxuXHQvKipcblx0ICogVGhlIHVuaXF1ZSBpZCBhbGxvY2F0ZWQgdG8gdGhlIGBUb2dnbGVgLlxuXHQgKi9cblx0aWQgPSBcInRvZ2dsZS1cIiArIFRvZ2dsZS50b2dnbGVDb3VudDtcblxuXHRwcm90ZWN0ZWQgX29mZlZhbHVlcyA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRPR0dMRS5PRkZcIik7XG5cdHByb3RlY3RlZCBfb25WYWx1ZXMgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUT0dHTEUuT05cIik7XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFRvZ2dsZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKHByb3RlY3RlZCBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsIHByb3RlY3RlZCBpMThuOiBJMThuKSB7XG5cdFx0c3VwZXIoY2hhbmdlRGV0ZWN0b3JSZWYpO1xuXHRcdFRvZ2dsZS50b2dnbGVDb3VudCsrO1xuXHR9XG5cblx0LyoqXG5cdCAqIGBDb250cm9sVmFsdWVBY2Nlc3NvcmAgbWV0aG9kIHRvIHByb2dyYW1tYXRpY2FsbHkgZGlzYWJsZSB0aGUgdG9nZ2xlIGlucHV0LlxuXHQgKlxuXHQgKiBleDogYHRoaXMuZm9ybUdyb3VwLmdldChcIm15VG9nZ2xlXCIpLmRpc2FibGUoKTtgXG5cdCAqXG5cdCAqIEBwYXJhbSBpc0Rpc2FibGVkIGB0cnVlYCB0byBkaXNhYmxlIHRoZSBpbnB1dFxuXHQgKi9cblx0c2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKSB7XG5cdFx0dGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG5cdH1cblxuXHRnZXRPZmZUZXh0KCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cdFx0cmV0dXJuIHRoaXMuX29mZlZhbHVlcy5zdWJqZWN0O1xuXHR9XG5cblx0Z2V0T25UZXh0KCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cdFx0cmV0dXJuIHRoaXMuX29uVmFsdWVzLnN1YmplY3Q7XG5cdH1cblxuXHRnZXRDaGVja2VkVGV4dCgpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuXHRcdGlmICh0aGlzLmNoZWNrZWQpIHtcblx0XHRcdHJldHVybiB0aGlzLl9vblZhbHVlcy5zdWJqZWN0O1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fb2ZmVmFsdWVzLnN1YmplY3Q7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBpbnN0YW5jZSBvZiBgVG9nZ2xlQ2hhbmdlYCB1c2VkIHRvIHByb3BhZ2F0ZSB0aGUgY2hhbmdlIGV2ZW50LlxuXHQgKi9cblx0ZW1pdENoYW5nZUV2ZW50KCkge1xuXHRcdHRoaXMuY2hlY2tlZENoYW5nZS5lbWl0KHRoaXMuY2hlY2tlZCk7XG5cdFx0dGhpcy5wcm9wYWdhdGVDaGFuZ2UodGhpcy5jaGVja2VkKTtcblx0fVxuXG5cdHB1YmxpYyBpc1RlbXBsYXRlKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVGVtcGxhdGVSZWY7XG5cdH1cbn1cbiJdfQ==